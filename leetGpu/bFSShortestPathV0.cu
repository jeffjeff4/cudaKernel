
#include <cuda_runtime.h>
#include <stdio.h>

__device__ const int DX[] = {0, 0, +1, -1};
__device__ const int DY[] = {-1, +1, 0, 0};

__global__ void move_kernel(
    const int* grid, int* dist, int rows, int cols, 
    const int *wave, int *wave_len, int *next_wave, int *next_wave_len
) {
    const int i = threadIdx.x + blockDim.x * blockIdx.x;
    
    if (i >= *wave_len) return;

    const int x = wave[2 * i];
    const int y = wave[2 * i + 1];

    const int idx = x * cols + y;
    const int next_dist = 1 + dist[idx];

    for (int i = 0 ; i < 4 ;i++ ){
        int nx = x + DX[i], ny = y + DY[i];
        const int nidx = nx * cols + ny;
        if (0 <= nx && 0 <= ny && nx < rows && ny < cols && !grid[nidx]) {
            //printf("will move (%d, %d) -> (%d, %d)\n", x, y, nx, ny);
            if(next_dist < atomicMin(dist + nidx, next_dist)) { // if we discovered the next node
                int loc = atomicAdd(next_wave_len, 1); // add it to the next wave
                next_wave[2 * loc] = nx;
                next_wave[2 * loc + 1] = ny;
            }
        }
    }
}

__host__ void debugDist(int *dist, int rows, int cols) {
    int *h_dist = new int[rows * cols];
    cudaMemcpy(h_dist, dist, sizeof(int) * rows * cols, cudaMemcpyDeviceToHost);
    for (int i = 0 ; i < rows * cols; i++) {
        if (h_dist[i] <= rows * cols)
            printf("%d ", h_dist[i]);
        else 
            printf("inf ");
    }
    printf("\n");
    delete[] h_dist;
}

__global__ void map_inf_to_neg_kernel(int *grid, int rows, int cols) {
    const int i = threadIdx.x + blockIdx.x * blockDim.x;
    if (i >= rows * cols) return;
    if (grid[i] > rows * cols) grid[i] = -1;
}

// grid, result are device pointers
extern "C" void solve(const int* grid, int* result, int rows, int cols, 
                     int start_row, int start_col, int end_row, int end_col) {
    const dim3 numThreads(128);
    const dim3 numBlocks((rows * cols + numThreads.x - 1) / numThreads.x);

    int *dist;

    cudaMalloc(&dist, rows * cols * sizeof(int));
    cudaMemset(dist, 0x63, rows * cols * sizeof(int)); // set initial distances to high values, too lazy to write a separate kernel for that
    cudaMemset(dist + start_row * cols + start_col, 0, sizeof(int)); // set initial distance to 0 only for start vertex
    
    int *wave[2];

    cudaMalloc(&wave[0], sizeof(int) + rows * cols * 2 * sizeof(int)); // extra int for length
    cudaMalloc(&wave[1], sizeof(int) + rows * cols * 2 * sizeof(int));

    int init_wave_len = 1;
    
    cudaMemcpy(wave[0], &init_wave_len, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[0]+1, &start_row, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[0]+2, &start_col, sizeof(int), cudaMemcpyHostToDevice);

    int wave_id = 0;
    int h_next_wave_len;

    do {
        int current = wave_id % 2;
        int alt = (wave_id + 1) % 2;
        cudaMemset(wave[alt], 0, sizeof(int)); // reset next wave len
        move_kernel<<<numBlocks, numThreads>>>(
            grid, dist, rows, cols,
            wave[current] + 1, wave[current],
            wave[alt] + 1, wave[alt]
        );
        cudaMemcpy(&h_next_wave_len, wave[alt], sizeof(int), cudaMemcpyDeviceToHost);
        wave_id++;
        //printf("wave#%d will have length: %d\n", wave_id, h_next_wave_len);
    } while (h_next_wave_len > 0);

    map_inf_to_neg_kernel<<<numBlocks, numThreads>>>(dist, rows, cols);

    // debugDist(dist, rows, cols);

    cudaMemcpy(result, dist + end_row * cols + end_col, sizeof(int), cudaMemcpyDeviceToDevice);

    cudaFree(dist); // be nice
}



//--------------------------------------------------------------------------------------------------
/*
question0:
ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

è¿™æ®µä»£ç å®ç°äº†ä¸€ä¸ªåŸºäº **GPU å¹¶è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ (Parallel Breadth-First Search, BFS)** çš„æœ€çŸ­è·¯å¾„ç®—æ³•ã€‚å®ƒåˆ©ç”¨ CUDA æ¥åœ¨ç½‘æ ¼ (grid) ä¸Šå¯»æ‰¾ä»ä¸€ä¸ªèµ·å§‹ç‚¹ (start_row, start_col) åˆ°ä¸€ä¸ªç»ˆç‚¹ (end_row, end_col) çš„æœ€çŸ­è·¯å¾„ã€‚

è¯¥ç®—æ³•çš„æ ¸å¿ƒæ˜¯ **æ³¢å‰æ¨è¿› (Wavefront Progression)** æ¨¡å¼ï¼Œå³åœ¨æ¯ä¸€æ­¥è¿­ä»£ä¸­ï¼ŒåŒæ—¶æ¢ç´¢å½“å‰æ³¢å‰ï¼ˆWaveï¼‰çš„æ‰€æœ‰ç›¸é‚»èŠ‚ç‚¹ã€‚

-----

## âš™ï¸ I. æ ¸å¿ƒæ¦‚å¿µä¸æ•°æ®ç»“æ„

### 1. BFS / æ³¢å‰æ¨è¿›

  * **ä¼ ç»Ÿ BFS:** ä½¿ç”¨é˜Ÿåˆ—ï¼Œé€ä¸ªèŠ‚ç‚¹æ¢ç´¢ã€‚
  * **å¹¶è¡Œ BFS:** åœ¨ GPU ä¸Šï¼Œä½¿ç”¨ wave æ•°ç»„å­˜å‚¨å½“å‰æ³¢å‰æ‰€æœ‰å¾…æ¢ç´¢çš„èŠ‚ç‚¹ã€‚æ¯ä¸€æ­¥è¿­ä»£ï¼Œæ‰€æœ‰çº¿ç¨‹åŒæ—¶å¤„ç† wave æ•°ç»„ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ï¼Œå¹¶è¡Œç”Ÿæˆä¸‹ä¸€æ³¢å‰ (next_wave)ã€‚

### 2. å…³é”®æ•°æ®

| å˜é‡ | ç±»å‹/ä½ç½® | ä½œç”¨ |
| :--- | :--- | :--- |
| grid | `const int*` (Device) | è¾“å…¥ç½‘æ ¼ã€‚`grid[idx]` ä¸º 0 è¡¨ç¤ºå¯é€šè¡Œï¼Œé 0 è¡¨ç¤ºéšœç¢ã€‚ |
| dist | `int*` (Device) | è·ç¦»æ•°ç»„ã€‚dist[idx] å­˜å‚¨ä»èµ·ç‚¹åˆ°è¯¥ç‚¹çš„**æœ€çŸ­è·ç¦»**ã€‚ |
| wave[2] | `int*` (Device) | **åŒç¼“å†²**ï¼šå­˜å‚¨å½“å‰æ³¢å‰å’Œä¸‹ä¸€æ³¢å‰çš„èŠ‚ç‚¹åæ ‡ã€‚ |
| wave_len | `int*` (Device/Host) | å­˜å‚¨æ³¢å‰æ•°ç»„çš„å®é™…é•¿åº¦ã€‚**å­˜å‚¨åœ¨ wave æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ä½ç½®**ã€‚ |
| **DX/DY** | `__device__ const int[]` | åç§»æ•°ç»„ï¼Œç”¨äºæ£€æŸ¥ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªé‚»å±…ã€‚ |

-----

## ğŸš€ II. Kernel å†…éƒ¨æµç¨‹ (`move_kernel`)

è¯¥ Kernel æ˜¯å¹¶è¡Œ BFS çš„ä¸»è¦å·¥ä½œå•å…ƒã€‚æ¯ä¸ªçº¿ç¨‹å¤„ç†å½“å‰æ³¢å‰ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ã€‚

### 1. çº¿ç¨‹åˆ†å·¥ä¸åæ ‡æå–

c
const int i = threadIdx.x + blockDim.x * blockIdx.x; // çº¿ç¨‹çš„å…¨å±€ç´¢å¼•
if (i >= *wave_len) return; // è¾¹ç•Œæ£€æŸ¥ï¼šçº¿ç¨‹åªå¤„ç† wave æ•°ç»„ä¸­çš„æœ‰æ•ˆèŠ‚ç‚¹

const int x = wave[2 * i];       // å½“å‰èŠ‚ç‚¹çš„è¡Œåæ ‡
const int y = wave[2 * i + 1];   // å½“å‰èŠ‚ç‚¹çš„åˆ—åæ ‡
const int idx = x * cols + y;
const int next_dist = 1 + dist[idx]; // é‚»å±…èŠ‚ç‚¹çš„ç†è®ºè·ç¦»


  * **æ³¢å‰ç´¢å¼• (i):** çº¿ç¨‹ ID ç›´æ¥å¯¹åº” wave æ•°ç»„ä¸­çš„ä¸€ä¸ªèŠ‚ç‚¹ç´¢å¼•ã€‚
  * **åæ ‡æå–:** ç”±äº wave æ•°ç»„å­˜å‚¨çš„æ˜¯ [x_0, y_0, x_1, y_1, ...] æ ¼å¼ï¼Œéœ€è¦ä¹˜ä»¥ 2 æ¥è·å–æ­£ç¡®çš„ x åæ ‡ã€‚

### 2. æ¢ç´¢é‚»å±…ä¸åˆæ³•æ€§æ£€æŸ¥

c
for (int i = 0 ; i < 4 ;i++ ){ // å¾ªç¯éå† 4 ä¸ªæ–¹å‘ï¼ˆä¸Šã€ä¸‹ã€å·¦ã€å³ï¼‰
    int nx = x + DX[i], ny = y + DY[i];
    const int nidx = nx * cols + ny;

    if (0 <= nx && 0 <= ny && nx < rows && ny < cols && !grid[nidx]) {
        // æ£€æŸ¥ï¼š1. æ˜¯å¦åœ¨ç½‘æ ¼å†…ï¼›2. æ˜¯å¦ä¸æ˜¯éšœç¢ç‰© (!grid[nidx])
        // ...
    



  * **å¾ªç¯:** éå† DX å’Œ DY æ•°ç»„ï¼Œæ£€æŸ¥ 4 ä¸ªé‚»å±… nx, ny)ã€‚
  * **åˆæ³•æ€§æ£€æŸ¥:** ç¡®ä¿é‚»å±…åœ¨ç½‘æ ¼è¾¹ç•Œå†…ï¼Œå¹¶ä¸”ä¸æ˜¯éšœç¢ç‰©ï¼ˆ`grid[nidx]` ä¸º 0ï¼‰ã€‚

### 3. æœ€çŸ­è·ç¦»æ›´æ–°ä¸ä¸‹ä¸€æ³¢å‰ç”Ÿæˆï¼ˆæ ¸å¿ƒï¼‰

c
// ... (åœ¨åˆæ³•é‚»å±…çš„ if å—å†…)
if(next_dist < atomicMin(dist + nidx, next_dist)) { // å°è¯•æ›´æ–°æœ€çŸ­è·ç¦»
    int loc = atomicAdd(next_wave_len, 1); // æˆåŠŸæ›´æ–°ï¼ŒåŠ å…¥ä¸‹ä¸€æ³¢å‰
    next_wave[2 * loc] = nx;
    next_wave[2 * loc + 1] = ny;



  * **atomicMin(dist + nidx, next_dist):** è¿™æ˜¯å…³é”®çš„**åŸå­æ“ä½œ**ã€‚å®ƒå°è¯•å°† dist[nidx] æ›´æ–°ä¸ºæ–°çš„ã€æ›´çŸ­çš„è·ç¦» next_distã€‚
      * **è¿”å›å€¼:** `atomicMin` è¿”å› **åŸå€¼**ã€‚
      * **åˆ¤æ–­:** å¦‚æœ **æ–°çš„è·ç¦» next_dist** å°äº **è¿”å›çš„åŸå€¼**ï¼Œè¯´æ˜è¿™æ¬¡æ›´æ–°æ˜¯æˆåŠŸçš„ï¼ˆå³å‘ç°äº†ä¸€æ¡æ›´çŸ­çš„è·¯å¾„ï¼‰ã€‚
  * **atomicAdd(next_wave_len, 1):** å¦‚æœæˆåŠŸæ›´æ–°è·ç¦»ï¼Œè¯´æ˜ (nx, ny) æ˜¯ä¸‹ä¸€æ³¢å‰çš„ä¸€ä¸ªæ–°èŠ‚ç‚¹ã€‚
      * atomicAdd è¿”å›ä¸‹ä¸€æ³¢å‰æ•°ç»„çš„**å½“å‰é•¿åº¦**ï¼ˆå³æ–°èŠ‚ç‚¹çš„ä½ç½® locï¼‰ã€‚
      * loc éšåç”¨äºå†™å…¥ next_wave æ•°ç»„ã€‚

-----

## ğŸ’» III. ä¸»æœºç«¯æ±‚è§£ (`solve` å‡½æ•°)

### 1. åˆå§‹åŒ–

c
cudaMemset(dist, 0x63, rows * cols * sizeof(int)); // åˆå§‹åŒ–è·ç¦»ä¸ºæå¤§å€¼
cudaMemset(dist + start_row * cols + start_col, 0, sizeof(int)); // èµ·ç‚¹è·ç¦»è®¾ä¸º 0
// ...
// wave[0] å­˜å‚¨åˆå§‹æ³¢å‰ (åªåŒ…å«èµ·ç‚¹)


### 2. è¿­ä»£æ³¢å‰æ¨è¿› (ä¸»å¾ªç¯)

c
do {
    // ...
    move_kernel<<<numBlocks, numThreads>>>(...); // å¯åŠ¨ Kernel
    cudaMemcpy(&h_next_wave_len, wave[alt], sizeof(int), cudaMemcpyDeviceToHost); // è·å–ä¸‹ä¸€æ³¢å‰é•¿åº¦
    wave_id++;
 while (h_next_wave_len > 0); // åªè¦ä¸‹ä¸€æ³¢å‰éç©ºï¼Œå°±ç»§ç»­è¿­ä»£


  * **åŒç¼“å†²:** å¾ªç¯åˆ©ç”¨ wave[0] å’Œ wave[1] ä¸¤ä¸ªæ•°ç»„äº¤æ›¿ä½œä¸ºå½“å‰æ³¢å‰å’Œä¸‹ä¸€æ³¢å‰ï¼Œå®ç°é«˜æ•ˆçš„è¯»å†™åˆ†ç¦»ã€‚
  * **ç»ˆæ­¢æ¡ä»¶:** å½“ä¸‹ä¸€æ³¢å‰é•¿åº¦ (h_next_wave_len) ä¸º 0 æ—¶ï¼Œè¯´æ˜æ‰€æœ‰å¯è¾¾èŠ‚ç‚¹éƒ½å·²è¢«æ¢ç´¢ï¼ŒBFS ç»“æŸã€‚

### 3. æœ€ç»ˆç»“æœ

  * `map_inf_to_neg_kernel`: å°†è·ç¦»æ•°ç»„ä¸­æœªè¢«è®¿é—®åˆ°çš„æå¤§å€¼ï¼ˆç›¸å½“äº \inftyï¼‰æ˜ å°„ä¸º -1ã€‚
  * `cudaMemcpy(result, dist + end_row * cols + end_col, ...)`: å°†ç»ˆç‚¹ end_row, end_col) çš„æœ€çŸ­è·ç¦»ä» dist æ•°ç»„ä¸­å–å‡ºï¼Œä½œä¸ºæœ€ç»ˆç»“æœè¿”å›ã€‚

//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question1:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­



    cudaMalloc(&wave[0], sizeof(int) + rows * cols * 2 * sizeof(int)); // extra int for length
    cudaMalloc(&wave[1], sizeof(int) + rows * cols * 2 * sizeof(int));
ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    int init_wave_len = 1;
    
    cudaMemcpy(wave[0], &init_wave_len, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[1], &start_row, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[2], &start_col, sizeof(int), cudaMemcpyHostToDevice);


answer:
æ‚¨é—®åˆ°çš„è¿™æ®µä»£ç æ˜¯å¹¶è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ç®—æ³•ä¸­ï¼Œ**åŒç¼“å†²ï¼ˆDouble Bufferingï¼‰æ³¢å‰æ•°ç»„**çš„åˆ†é…å’Œåˆå§‹åŒ–çš„å…³é”®æ­¥éª¤ã€‚

æ ¸å¿ƒåœ¨äºç†è§£ wave[0] å’Œ wave[1] æ•°ç»„çš„ç»“æ„å’Œç”¨é€”ï¼Œä»¥åŠä¸ºä»€ä¹ˆå®ƒä»¬åœ¨å†…å­˜ä¸­å­˜å‚¨äº†é•¿åº¦ä¿¡æ¯ã€‚

-----

## âš™ï¸ I. æ ¸å¿ƒç»“æ„ï¼šåŒç¼“å†²æ³¢å‰æ•°ç»„

åœ¨å¹¶è¡Œ BFS ä¸­ï¼Œæˆ‘ä»¬éœ€è¦ä¸¤ä¸ª GPU æ•°ç»„æ¥å­˜å‚¨å½“å‰æ­£åœ¨æ¢ç´¢çš„èŠ‚ç‚¹å’Œä¸‹ä¸€ä¸ªå°†è¦æ¢ç´¢çš„èŠ‚ç‚¹ï¼Œä»¥é¿å…è¯»å†™å†²çªã€‚

### 1. å†…å­˜åˆ†é… (`cudaMalloc`)

c
cudaMalloc(&wave[0], sizeof(int) + rows * cols * 2 * sizeof(int)); // wave[0] çš„åˆ†é…
// wave[1] çš„åˆ†é…ç±»ä¼¼


  * **`wave[0]` å’Œ `wave[1]`:** è¿™æ˜¯ä¸¤ä¸ªç‹¬ç«‹çš„ GPU æŒ‡é’ˆï¼Œç”¨äºå®ç° Ping-Pong æœºåˆ¶ã€‚
  * **è®¡ç®—æ€»å­—èŠ‚æ•°:**
      * rows * colsï¼šç½‘æ ¼ä¸­çš„æ€»èŠ‚ç‚¹æ•°ã€‚
      * * 2 * sizeof(int)ï¼šæ¯ä¸ªèŠ‚ç‚¹éœ€è¦ 2 ä¸ª `int` æ¥å­˜å‚¨åæ ‡ (x, y)ã€‚
      * + sizeof(int)ï¼š**é¢å¤–çš„ 1 ä¸ª `int`**ï¼Œç”¨äºå­˜å‚¨**æ•°ç»„çš„å½“å‰æœ‰æ•ˆé•¿åº¦** (wave_len)ã€‚

> **æ€»ç»“ï¼š** æ¯ä¸ª `wave` æ•°ç»„çš„å†…å­˜å¸ƒå±€æ˜¯ï¼š`[ æ•°ç»„é•¿åº¦ (wave_len) | x0 | y0 | x1 | y1 | ... ]`

### 2. ä¸ºä»€ä¹ˆéœ€è¦ wave_len å­˜å‚¨åœ¨æ•°ç»„å†…éƒ¨ï¼Ÿ

  * åœ¨ Kernel (`move_kernel`) ä¸­ï¼Œæˆ‘ä»¬éœ€è¦çŸ¥é“å½“å‰æ³¢å‰æ•°ç»„çš„æœ‰æ•ˆé•¿åº¦ (`*wave_len`) æ¥æ§åˆ¶çº¿ç¨‹çš„æ•°é‡ (`if (i >= *wave_len) return;`)ã€‚
  * åŒæ—¶ï¼Œæˆ‘ä»¬ä¹Ÿéœ€è¦å†™å…¥ä¸‹ä¸€æ³¢å‰æ•°ç»„çš„é•¿åº¦ (`atomicAdd(next_wave_len, 1)`ã€‚
  * å°†é•¿åº¦å­˜å‚¨åœ¨æ•°ç»„çš„ **èµ·å§‹ä½ç½®** (wave[i][0]) æ˜¯ä¸€ç§é«˜æ•ˆçš„æƒ¯ä¾‹ï¼Œå…è®¸æˆ‘ä»¬åœ¨ Kernel ä¸­ä½¿ç”¨ **åŸå­æ“ä½œ** (`atomicAdd`) æ¥æ›´æ–°ä¸‹ä¸€æ³¢å‰çš„é•¿åº¦ï¼Œæ— éœ€é¢å¤–çš„å…¨å±€å†…å­˜åˆ†é…ã€‚

-----

## ğŸ”¢ II. åˆå§‹æ³¢å‰è®¾ç½® (Start Node)

åˆå§‹åŒ–æ­¥éª¤æ˜¯å°†èµ·ç‚¹ start_row, start_col) æ”¾å…¥æ³¢å‰æ•°ç»„ wave[0] ä¸­ï¼Œå¹¶è®¾ç½®å…¶é•¿åº¦ã€‚

å‡è®¾ï¼š

  * start_row = 5
  * start_col = 10
  * init_wave_len = 1

| å†…å­˜æ“ä½œ | æºæ•°æ® | ç›®æ ‡åœ°å€ | å­˜å‚¨å†…å®¹ |
| :--- | :--- | :--- | :--- |
| `cudaMemcpy(wave[0], &init_wave_len, ...)` | 1 | wave[0] çš„èµ·å§‹åœ°å€ | **æ•°ç»„é•¿åº¦ (wave_len)** |
| `cudaMemcpy(wave[1], &start_row, ...)` | 5 | wave[0] + sizeof(int) * 1 | **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ X åæ ‡ (x0)** |
| `cudaMemcpy(wave[2], &start_col, ...)` | 10 | wave[0] + sizeof(int) * 2 | **ç¬¬ä¸€ä¸ªèŠ‚ç‚¹ Y åæ ‡ (y0)** |

> **æ³¨æ„ï¼š** `wave[1]` å’Œ `wave[2]` åœ¨ C è¯­è¨€ä¸­æ˜¯é”™è¯¯çš„å†™æ³•ï¼ˆå› ä¸º `wave` æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œä¸æ˜¯ä¸€ä¸ªæŒ‡é’ˆï¼‰ã€‚ä½†æ ¹æ®ä¸Šä¸‹æ–‡ï¼Œè¿™ä¸‰è¡Œä»£ç çš„æ„å›¾æ˜¯å°† start_row, start_col) åæ ‡å†™å…¥ wave[0] æ•°ç»„ä¸­ï¼Œç´§è·Ÿåœ¨é•¿åº¦ä¹‹åã€‚

### æ•°ç»„ wave[0] åœ¨ GPU å†…å­˜ä¸­çš„å¸ƒå±€:

| å†…å­˜ç´¢å¼• (ä»¥ `int` ä¸ºå•ä½) | å­˜å‚¨å€¼ | ä½œç”¨ |
| :--- | :--- | :--- |
| **0** | **1** | wave_len (å½“å‰æ³¢å‰é•¿åº¦) |
| **1** | **5** | x_0 (start_row) |
| **2** | **10** | y_0 (start_col) |
| 3 | (ç©º) | x_1 |
| 4 | (ç©º) | y_1 |
| ... | ... | ... |

**æ€»ç»“ï¼š** è¿™æ®µåˆå§‹åŒ–ä»£ç å°† BFS çš„èµ·ç‚¹å®‰å…¨åœ°åŠ è½½åˆ°äº†ç¬¬ä¸€ä¸ªæ³¢å‰æ•°ç»„ä¸­ï¼Œå¹¶è®¾ç½®é•¿åº¦ä¸º 1ï¼Œä»è€Œå¯åŠ¨äº†æ•´ä¸ªå¹¶è¡Œ BFS è¿‡ç¨‹ã€‚


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question2:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

å¦‚æœæ•°ç»„ wave[0] åœ¨ GPU å†…å­˜ä¸­çš„å¸ƒå±€:

å†…å­˜ç´¢å¼• (ä»¥ int ä¸ºå•ä½)å­˜å‚¨å€¼ä½œç”¨01wave_len (å½“å‰æ³¢å‰é•¿åº¦)15x_0 (start_row)210y_0 (start_col)3(ç©º)x_14(ç©º)y_1.........

é‚£ä¹ˆ
    cudaMalloc(&wave[1], sizeof(int) + rows * cols * 2 * sizeof(int));
ä¸­wave[1]çš„å€¼æ˜¯å•¥ï¼Ÿ

answer:
è¿™æ˜¯ä¸€ä¸ªå…³äº **C è¯­è¨€æ•°ç»„ä¸æŒ‡é’ˆ** ä»¥åŠ **`cudaMalloc`** å¦‚ä½•å·¥ä½œçš„æŠ€æœ¯é—®é¢˜ã€‚

åœ¨æ‚¨è¿™æ®µä»£ç ä¸­ï¼Œ`wave` æ˜¯ä¸€ä¸ªåŒ…å«ä¸¤ä¸ªæŒ‡é’ˆçš„æ•°ç»„ï¼Œ`wave[0]` å’Œ `wave[1]`ã€‚

-----

## âš™ï¸ I. ä»£ç å®šä¹‰è§£æ

é¦–å…ˆï¼Œ`wave` çš„å®šä¹‰å’Œä½¿ç”¨åœ¨ C è¯­è¨€ä¸­å­˜åœ¨æ­§ä¹‰ï¼Œä½†åœ¨ CUDA ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬å‡è®¾å®ƒè¢«å®šä¹‰ä¸ºï¼š

c
int *wave[2]; // wave æ˜¯ä¸€ä¸ªåŒ…å«ä¸¤ä¸ª int* æŒ‡é’ˆçš„æ•°ç»„


### 1. `cudaMalloc` çš„ä½œç”¨

`cudaMalloc(&wave[1], size)` å‡½æ•°æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1.  åœ¨ GPU çš„å…¨å±€å†…å­˜ (Global Memory) ä¸­æ‰¾åˆ°ä¸€å—è¶³å¤Ÿå¤§çš„è¿ç»­å†…å­˜ç©ºé—´ã€‚
2.  å°†è¿™å—æ–°åˆ†é…çš„ **GPU å†…å­˜çš„èµ·å§‹åœ°å€** èµ‹å€¼ç»™ä¸»æœºç«¯çš„æŒ‡é’ˆå˜é‡ **`wave[1]`**ã€‚

### 2. `wave[1]` çš„å€¼

å› æ­¤ï¼Œ`wave[1]` çš„å€¼æ˜¯ï¼š

**`wave[1]` çš„å€¼æ˜¯ GPU å†…å­˜ä¸­ä¸€å—æ–°åˆ†é…çš„ã€èµ·å§‹åœ°å€è¾ƒé«˜çš„æ•´æ•°åœ°å€ã€‚**

  * **ç±»å‹:** å®ƒæ˜¯ `int*` (æŒ‡å‘ GPU å†…å­˜çš„æŒ‡é’ˆ)ã€‚
  * **å€¼:** ä¸€ä¸ª 64 ä½æ•´æ•°ï¼Œä»£è¡¨ GPU ä¸Šçš„è™šæ‹Ÿåœ°å€ã€‚

-----

## ğŸš€ II. ä¸ `wave[0]` çš„å…³ç³»

| æŒ‡é’ˆ | ä½œç”¨ | å†…å®¹ (å€¼) |
| :--- | :--- | :--- |
| **`wave`** | ä¸»æœºç«¯æ•°ç»„ | å­˜å‚¨ç€ä¸¤ä¸ª GPU åœ°å€ã€‚ |
| **`wave[0]`** | GPU å†…å­˜åœ°å€ 1 | æŒ‡å‘ GPU å†…å­˜ä¸­å­˜å‚¨æ³¢å‰æ•°æ®çš„ç¬¬ä¸€ä¸ªç¼“å†²åŒº (Buffer 0)ã€‚ |
| **`wave[1]`** | GPU å†…å­˜åœ°å€ 2 | æŒ‡å‘ GPU å†…å­˜ä¸­å­˜å‚¨æ³¢å‰æ•°æ®çš„ç¬¬äºŒä¸ªç¼“å†²åŒº (Buffer 1)ã€‚ |

**å…³é”®ç‚¹ï¼š**

  * **`wave[0]` å’Œ `wave[1]` éƒ½æ˜¯ç‹¬ç«‹çš„ GPU åœ°å€ã€‚** å®ƒä»¬æŒ‡å‘ä¸¤å—ç‰©ç†ä¸Šä¸è¿ç»­çš„ GPU å†…å­˜åŒºåŸŸï¼Œå„è‡ªç”¨äºå­˜å‚¨ä¸€ä¸ªå®Œæ•´çš„æ³¢å‰æ•°ç»„ (åŒ…æ‹¬é•¿åº¦å’Œåæ ‡)ã€‚
  * **`wave[1]` çš„å€¼** å°±æ˜¯ CUDA è¿è¡Œæ—¶ç³»ç»Ÿä¸ºç¬¬äºŒä¸ªæ³¢å‰ç¼“å†²åŒºåˆ†é…çš„èµ·å§‹åœ°å€ã€‚

//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question3:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

è¿™3ä¸ªå€¼æ˜¯åœ¨&wave[0]ï¼Œè¿˜æ˜¯&wave[1]ï¼Ÿ
    cudaMemcpy(wave[0], &init_wave_len, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[1], &start_row, sizeof(int), cudaMemcpyHostToDevice);
    cudaMemcpy(wave[2], &start_col, sizeof(int), cudaMemcpyHostToDevice);

answer:
è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„æŠ€æœ¯æ€§è§‚å¯Ÿã€‚æ ¹æ®æ‚¨æä¾›çš„ä»£ç å’Œ C/CUDA çš„æŒ‡é’ˆè§„åˆ™ï¼Œè¿™ä¸‰ä¸ªå€¼ **éƒ½è¢«å†™å…¥äº†ç¬¬ä¸€ä¸ªæ³¢å‰æ•°ç»„çš„å†…å­˜åŒºåŸŸï¼Œå³ `wave[0]` æ‰€æŒ‡å‘çš„ GPU å†…å­˜åœ°å€ï¼Œä½†å†™å…¥çš„æŒ‡é’ˆè¡¨è¾¾æ–¹å¼åœ¨ C è¯­æ³•ä¸Šæ˜¯è¯¯å¯¼æ€§çš„ã€‚**

-----

## âš™ï¸ ä¸ºä»€ä¹ˆæ‰€æœ‰çš„å€¼éƒ½åœ¨ wave[0] çš„å†…å­˜åŒºåŸŸï¼Ÿ

åœ¨æ‚¨æä¾›çš„ `solve` å‡½æ•°ä¸­ï¼Œ`wave` æ•°ç»„çš„åˆå§‹åŒ–æ˜¯è¿™æ ·çš„ï¼š

c
// å‡è®¾ wave è¢«å®šä¹‰ä¸º int *wave[2]; (åŒ…å«ä¸¤ä¸ª GPU åœ°å€çš„æ•°ç»„)

// wave[0] åˆ†é…äº†è¶³å¤Ÿçš„ç©ºé—´æ¥å­˜å‚¨ [é•¿åº¦] å’Œ [åæ ‡]
cudaMalloc(&wave[0], sizeof(int) + rows * cols * 2 * sizeof(int));
// wave[1] åˆ†é…äº†ç¬¬äºŒä¸ªç‹¬ç«‹çš„ç¼“å†²åŒº
cudaMalloc(&wave[1], sizeof(int) + rows * cols * 2 * sizeof(int));

// ... éšåè¿›è¡Œæ•°æ®æ‹·è´ ...


### 1. wave[0] çš„å†…å­˜å¸ƒå±€ (ç›®æ ‡)

`wave[0]` æŒ‡å‘çš„ GPU å†…å­˜åŒºåŸŸæ˜¯ç”¨äºå­˜å‚¨ **ç¬¬ä¸€ä¸ªæ³¢å‰ (Wave 0)** çš„æ•°æ®çš„ã€‚å…¶ç»“æ„æ˜¯ï¼š

| å†…å­˜ç´¢å¼• (int) | ä½œç”¨ |
| :--- | :--- |
| **wave[0] + 0** | å­˜å‚¨æ³¢å‰é•¿åº¦ (init_wave_len) |
| **wave[0] + 1** | å­˜å‚¨ x_0 åæ ‡ (start_row) |
| **wave[0] + 2** | å­˜å‚¨ y_0 åæ ‡ (start_col) |

### 2. ä»£ç çš„å®é™…æ‰§è¡Œ (è¯­æ³•é—®é¢˜)

æ‚¨çš„ä¸‰è¡Œ `cudaMemcpy` ä»£ç çš„**æ„å›¾**æ˜¯æŒ‰é¡ºåºå†™å…¥è¿™ä¸‰ä¸ªä½ç½®ï¼Œä½†å®ƒä½¿ç”¨äº†åœ¨æ ‡å‡† C/C++ ä¸­å¯¹æ•°ç»„çš„**é”™è¯¯ç´¢å¼•**æ–¹å¼ï¼š

  * **ç¬¬ä¸€è¡Œï¼š** cudaMemcpy(wave[0], ...)

      * `wave[0]` æ˜¯ä¸€ä¸ª `int*` æŒ‡é’ˆã€‚å®ƒå°† `init_wave_len` å†™å…¥åœ°å€ `wave[0]`ï¼Œå³ **ç´¢å¼• 0**ã€‚

  * **ç¬¬äºŒè¡Œï¼š** cudaMemcpy(wave[1], ...)

      * **è¿™æ˜¯é”™è¯¯çš„ C è¯­è¨€æŒ‡é’ˆç”¨æ³•ï¼** è¿™é‡Œçš„ `wave[1]` æŒ‡å‘çš„æ˜¯**ç¬¬äºŒä¸ªç‹¬ç«‹çš„æ³¢å‰ç¼“å†²åŒº**çš„èµ·å§‹åœ°å€ã€‚
      * **å¼€å‘è€…çœŸæ­£çš„æ„å›¾æ˜¯ï¼š** å†™å…¥ **`wave[0]` æ‰€æŒ‡å‘çš„å†…å­˜çš„ç´¢å¼• 1 å¤„**ã€‚
      * **æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯ï¼š** `cudaMemcpy(wave[0] + 1, &start_row, ...)`

  * **ç¬¬ä¸‰è¡Œï¼š** cudaMemcpy(wave[2], ...)

      * **è¿™æ˜¯é”™è¯¯çš„ C è¯­è¨€æŒ‡é’ˆç”¨æ³•ï¼**
      * **å¼€å‘è€…çœŸæ­£çš„æ„å›¾æ˜¯ï¼š** å†™å…¥ **`wave[0]` æ‰€æŒ‡å‘çš„å†…å­˜çš„ç´¢å¼• 2 å¤„**ã€‚
      * **æ­£ç¡®çš„å†™æ³•åº”è¯¥æ˜¯ï¼š** `cudaMemcpy(wave[0] + 2, &start_col, ...)`

### ç»“è®ºï¼š

ç”±äºç¨‹åºæ—¨åœ¨åˆå§‹åŒ– **ç¬¬ä¸€ä¸ªæ³¢å‰ (`wave[0]`)**ï¼Œæˆ‘ä»¬å¯ä»¥æ¨æ–­å¼€å‘è€…æ˜¯æƒ³è®©è¿™ä¸‰ä¸ªå€¼è¿ç»­å­˜å‚¨åœ¨ wave[0] å†…å­˜åŒºåŸŸä¸­ï¼Œä½œä¸ºèµ·å§‹èŠ‚ç‚¹ x, y çš„åæ ‡å’Œæ³¢å‰é•¿åº¦ã€‚

**ä¸‰ä¸ªå€¼éƒ½å±äº wave[0] æ‰€æŒ‡å‘çš„å†…å­˜åŒºåŸŸã€‚**

## ğŸ”¢ æœ€ç»ˆå†…å­˜å¸ƒå±€ç¤ºä¾‹

å‡è®¾ `wave[0]` çš„åœ°å€æ˜¯ `0x4000` (GPU å†…å­˜)ã€‚

| C è¯­æ³• (æ„å›¾) | ç›®æ ‡åœ°å€ (ç‰©ç†) | å­˜å‚¨å€¼ | ä½œç”¨ |
| :--- | :--- | :--- | :--- |
| `wave[0]` | `0x4000` | init_wave_len (1) | **æ³¢å‰é•¿åº¦** |
| `wave[0] + 1` | `0x4004` (é”™å†™ä¸º `wave[1]`) | start_row (5) | **èŠ‚ç‚¹ X åæ ‡** |
| `wave[0] + 2` | `0x4008` (é”™å†™ä¸º `wave[2]`) | start_col (10) | **èŠ‚ç‚¹ Y åæ ‡** |


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question4:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    int wave_id = 0;
    int h_next_wave_len;

    do {
        int current = wave_id % 2;
        int alt = (wave_id + 1) % 2;
        cudaMemset(wave[alt], 0, sizeof(int)); // reset next wave len
        move_kernel<<<numBlocks, numThreads>>>(
            grid, dist, rows, cols,
            wave[current] + 1, wave[current],
            wave[alt] + 1, wave[alt]
        );
        cudaMemcpy(&h_next_wave_len, wave[alt], sizeof(int), cudaMemcpyDeviceToHost);
        wave_id++;
        //printf("wave#%d will have length: %d\n", wave_id, h_next_wave_len);
     while (h_next_wave_len > 0);

answer:
è¿™æ®µä»£ç æ˜¯å¹¶è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ï¼ˆBFSï¼‰ç®—æ³•åœ¨ä¸»æœºç«¯ï¼ˆCPUï¼‰çš„æ ¸å¿ƒ**è¿­ä»£å¾ªç¯**ï¼Œå®ç°äº† **æ³¢å‰æ¨è¿›ï¼ˆWavefront Progressionï¼‰**ã€‚

å®ƒçš„ä¸»è¦ç›®çš„æ˜¯ï¼š**ä¸æ–­åœ°äº¤æ›¿ä½¿ç”¨ä¸¤ä¸ªç¼“å†²åŒºï¼ˆåŒç¼“å†²ï¼‰ï¼Œå¯åŠ¨ Kernelï¼Œç›´åˆ°æ‰€æœ‰çš„å¯è¾¾èŠ‚ç‚¹éƒ½è¢«æ¢ç´¢å®Œæ¯•**ã€‚

---

## âš™ï¸ I. æ ¸å¿ƒæœºåˆ¶ï¼šåŒç¼“å†²ï¼ˆPing-Pongï¼‰BFS

å¹¶è¡Œ BFS çš„å…³é”®æŒ‘æˆ˜æ˜¯ï¼šçº¿ç¨‹æ­£åœ¨**è¯»å–**å½“å‰æ³¢å‰ï¼ˆWaveï¼‰æ—¶ï¼Œä¸èƒ½è®©å…¶ä»–çº¿ç¨‹åŒæ—¶**å†™å…¥**ä¸‹ä¸€æ³¢å‰ï¼ˆNext Waveï¼‰ã€‚åŒç¼“å†²è§£å†³äº†è¿™ä¸ªé—®é¢˜ã€‚

### 1. å…³é”®å˜é‡

* **`wave_id` (0, 1, 2, ...):** è¿­ä»£è®¡æ•°å™¨ï¼Œå†³å®šå½“å‰æ˜¯ç¬¬å‡ è½®æ¢ç´¢ã€‚
* **`current` (wave_id mod 2):** å½“å‰æ­£åœ¨**è¯»å–**çš„æ³¢å‰ï¼ˆæºï¼‰ã€‚
* **`alt` ((wave_id + 1) mod 2):** ä¸‹ä¸€æ³¢å‰ï¼Œæ˜¯å½“å‰**å†™å…¥**çš„ç›®æ ‡ç¼“å†²åŒºã€‚
* **`h_next_wave_len`:** ä¸»æœºç«¯çš„å˜é‡ï¼Œç”¨äºæ¥æ”¶ä¸‹ä¸€æ³¢å‰çš„å®é™…é•¿åº¦ï¼Œä½œä¸ºç»ˆæ­¢æ¡ä»¶ã€‚

## ğŸš€ II. è¿­ä»£æµç¨‹ä¸ç¤ºä¾‹

å‡è®¾æˆ‘ä»¬æ­£åœ¨ç½‘æ ¼ä¸Šæ‰§è¡Œ BFSï¼Œç›®æ ‡æ˜¯è®¡ç®—æœ€çŸ­è·¯å¾„ã€‚

| æ­¥éª¤ | ä»£ç  | ä½œç”¨å’ŒçŠ¶æ€ |
| :--- | :--- | :--- |
| **0. åˆå§‹åŒ–** | `wave_id = 0` | åˆå§‹æ³¢å‰ (Wave 0) å­˜å‚¨åœ¨ `wave[0]` ä¸­ï¼Œé•¿åº¦ä¸º 1ã€‚ |
| **1. ç¼“å†²åŒºåˆ‡æ¢** | `current = 0`, `alt = 1` | **æº:** `wave[0]` (å½“å‰æ³¢å‰)ã€‚ **ç›®æ ‡:** `wave[1]` (ä¸‹ä¸€æ³¢å‰)ã€‚ |
| **2. é•¿åº¦æ¸…é›¶** | `cudaMemset(wave[alt], 0, sizeof(int));` | å°†ç›®æ ‡ç¼“å†²åŒº `wave[1]` çš„**é•¿åº¦è®¡æ•°å™¨**æ¸…é›¶ã€‚å¿…é¡»æ¸…é›¶ï¼Œå› ä¸º `move_kernel` ä¼šä½¿ç”¨åŸå­åŠ æ³• (`atomicAdd`) æ¥ç´¯åŠ æ–°èŠ‚ç‚¹çš„æ•°é‡ã€‚ |
| **3. å¯åŠ¨ Kernel** | `move_kernel<<<...>>>(..., wave[current] + 1, wave[current], wave[alt] + 1, wave[alt]);` | **è®¡ç®—:** GPU å¼€å§‹æ¢ç´¢ `wave[current]` ä¸­çš„æ‰€æœ‰èŠ‚ç‚¹ã€‚æ¯å‘ç°ä¸€ä¸ªæ–°é‚»å±…ï¼Œå°±ä½¿ç”¨ `atomicAdd` å°†å…¶åæ ‡å†™å…¥ `wave[alt] + 1`ï¼Œå¹¶å°† `wave[alt]`ï¼ˆé•¿åº¦ï¼‰åŠ  1ã€‚ |
| **4. æ£€æŸ¥ç»ˆæ­¢** | `cudaMemcpy(&h_next_wave_len, wave[alt], sizeof(int), cudaMemcpyDeviceToHost);` | CPU ä» GPU è¯»å–ä¸‹ä¸€æ³¢å‰ (`wave[alt]`) çš„**æœ€ç»ˆé•¿åº¦**ã€‚ |
| **5. è¿­ä»£** | `wave_id++;` | `wave_id` å˜ä¸º 1ã€‚ |
| **6. å¾ªç¯åˆ¤æ–­** | `while (h_next_wave_len > 0);` | **åªè¦**ä¸‹ä¸€æ³¢å‰æœ‰æ–°èŠ‚ç‚¹ï¼ˆé•¿åº¦å¤§äº 0ï¼‰ï¼Œå°±ç»§ç»­ä¸‹ä¸€è½®æ¢ç´¢ã€‚ |

### ç¤ºä¾‹ï¼ˆç¬¬ 2 è½®è¿­ä»£ï¼‰

* **çŠ¶æ€:** wave_id = 1ã€‚
* **ç¼“å†²åŒºåˆ‡æ¢:** `current = 1`ï¼Œ`alt = 0`ã€‚
* **æ“ä½œ:**
    * **æº:** è¯»å– `wave[1]`ï¼ˆä¸Šä¸€è½®çš„ç»“æœï¼‰ã€‚
    * **ç›®æ ‡:** å†™å…¥ `wave[0]`ã€‚
* **ç»ˆæ­¢:** å¦‚æœ `h_next_wave_len` æœ€ç»ˆä¸º 0ï¼Œè¯´æ˜å½“å‰æ³¢å‰æ²¡æœ‰å‘ç°ä»»ä½•æ–°çš„ã€æœªæ¢ç´¢çš„èŠ‚ç‚¹ï¼Œç®—æ³•æ”¶æ•›ã€‚

## ğŸ¯ æ€»ç»“

è¿™ä¸ª `do-while` å¾ªç¯æ˜¯å¹¶è¡Œ BFS çš„**è¿­ä»£å¼•æ“**ã€‚å®ƒé€šè¿‡ä¸æ–­åˆ‡æ¢ `wave[0]` å’Œ `wave[1]` çš„è§’è‰²ï¼Œç¡®ä¿ GPU å§‹ç»ˆåœ¨è®¡ç®—æœ‰æ•ˆæ•°æ®ï¼Œè€Œ `atomicAdd` æœºåˆ¶ä¿è¯äº†å¤šä¸ªçº¿ç¨‹å¯ä»¥å®‰å…¨åœ°å‘ä¸‹ä¸€æ³¢å‰æ·»åŠ èŠ‚ç‚¹ã€‚å½“æ•´ä¸ªå›¾è¢«éå†æˆ–æ— æ³•æ‰¾åˆ°æ–°è·¯å¾„æ—¶ï¼Œå¾ªç¯ç»ˆæ­¢ã€‚ 


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question5:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

__global__ void move_kernel(
    const int* grid, int* dist, int rows, int cols, 
    const int *wave, int *wave_len, int *next_wave, int *next_wave_len
) {


answer:
è¿™æ®µä»£ç æ˜¯ **å¹¶è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ (Parallel Breadth-First Search, BFS)** ç®—æ³•çš„æ ¸å¿ƒ Kernelï¼Œåä¸º `move_kernel`ã€‚å®ƒçš„ä»»åŠ¡æ˜¯è®© GPU ä¸Šçš„æ¯ä¸ªçº¿ç¨‹åŒæ—¶æ¢ç´¢å½“å‰æ³¢å‰ (wave) ä¸­ä¸€ä¸ªèŠ‚ç‚¹çš„æ‰€æœ‰ç›¸é‚»é‚»å±…ï¼Œå¹¶ç”Ÿæˆä¸‹ä¸€æ³¢å‰ (next_wave)ã€‚

-----

## âš™ï¸ I. çº¿ç¨‹åˆ†å·¥ä¸æ³¢å‰èŠ‚ç‚¹å®šä½

### 1. çº¿ç¨‹åˆ°èŠ‚ç‚¹çš„æ˜ å°„

c
const int i = threadIdx.x + blockDim.x * blockIdx.x; // çº¿ç¨‹çš„å…¨å±€ç´¢å¼•
if (i >= *wave_len) return;


  * **ç›®æ ‡:** çº¿ç¨‹ i è´Ÿè´£å¤„ç† wave æ•°ç»„ä¸­çš„ç¬¬ i ä¸ªèŠ‚ç‚¹ã€‚
  * **`*wave_len`:** è¿™æ˜¯å½“å‰æ³¢å‰ä¸­**æœ‰æ•ˆèŠ‚ç‚¹**çš„æ€»æ•°ï¼ˆå­˜å‚¨åœ¨ `wave` æ•°ç»„æŒ‡é’ˆæŒ‡å‘çš„åœ°å€ï¼‰ã€‚è¾¹ç•Œæ£€æŸ¥ç¡®ä¿å¤šä½™çš„çº¿ç¨‹é€€å‡ºã€‚

### 2. åæ ‡æå–

c
const int x = wave[2 * i];
const int y = wave[2 * i + 1];

const int idx = x * cols + y;
const int next_dist = 1 + dist[idx];


  * **åæ ‡æå–:** wave æ•°ç»„å­˜å‚¨èŠ‚ç‚¹çš„åæ ‡ï¼Œæ ¼å¼ä¸º [x_0, y_0, x_1, y_1, ...]ã€‚å› æ­¤ï¼Œçº¿ç¨‹ i çš„ x åæ ‡åœ¨ 2 * i å¤„ï¼Œy åæ ‡åœ¨ 2 * i + 1 å¤„ã€‚
  * **`idx`:** å½“å‰èŠ‚ç‚¹ x, y) åœ¨ç½‘æ ¼ï¼ˆ`grid` æˆ– `dist`ï¼‰ä¸­çš„ä¸€ç»´ç´¢å¼•ã€‚
  * **`next_dist`:** å½“å‰èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦» (dist[idx]) åŠ  1ã€‚è¿™æ˜¯åˆ°è¾¾ä»»ä½•é‚»å±…çš„**ç†è®ºæ–°è·ç¦»**ã€‚

> **ç¤ºä¾‹:** å‡è®¾ wave = [5, 10, 8, 15, ...] (å­˜å‚¨äº†ä¸¤ä¸ªèŠ‚ç‚¹çš„åæ ‡ï¼š(5, 10) å’Œ (8, 15))ã€‚
>
>   * çº¿ç¨‹ i=0 æå– x=5, y=10ã€‚
>   * çº¿ç¨‹ i=1 æå– x=8, y=15ã€‚

-----

## ğŸ§­ II. æ ¸å¿ƒé€»è¾‘ï¼šæ¢ç´¢ä¸åŸå­æ›´æ–°

çº¿ç¨‹ i ç°åœ¨éå†å½“å‰èŠ‚ç‚¹ x, y) çš„å››ä¸ªé‚»å±…ã€‚

### 1. é‚»å±…å’Œåˆæ³•æ€§æ£€æŸ¥

c
for (int i = 0 ; i < 4 ;i++ ){
    int nx = x + DX[i], ny = y + DY[i]; // è®¡ç®—é‚»å±…åæ ‡
    const int nidx = nx * cols + ny;

    if (0 <= nx && 0 <= ny && nx < rows && ny < cols && !grid[nidx]) {
        // è¾¹ç•Œæ£€æŸ¥ && éšœç¢ç‰©æ£€æŸ¥ (!grid[nidx] è¡¨ç¤ºå¯é€šè¡Œ)
        // ...
    



### 2. æœ€çŸ­è·ç¦»æ›´æ–°ï¼ˆåŸå­æ“ä½œï¼‰

c
if(next_dist < atomicMin(dist + nidx, next_dist)) { // æ£€æŸ¥æ˜¯å¦æ‰¾åˆ°äº†æ›´çŸ­çš„è·¯å¾„
    // ...



  * **æœºåˆ¶:** è¿™æ˜¯å¹¶è¡Œ BFS çš„å…³é”®ã€‚`atomicMin(dist + nidx, next_dist)` å°è¯•å°†é‚»å±…èŠ‚ç‚¹ dist[nidx] çš„å€¼æ›´æ–°ä¸º next_distã€‚
      * **è¿”å›å€¼:** `atomicMin` è¿”å› **åŸå…ˆå­˜å‚¨åœ¨ dist[nidx] ä¸­çš„å€¼**ã€‚
      * **åˆ¤æ–­:** å¦‚æœ next_dist å°äº `atomicMin` è¿”å›çš„**åŸå€¼**ï¼Œè¯´æ˜æˆ‘ä»¬åˆšåˆšå‘ç°äº†ä¸€æ¡æ›´çŸ­çš„è·¯å¾„ï¼ˆæˆ–è€…è¿™æ˜¯ç¬¬ä¸€æ¬¡è®¿é—®è¯¥èŠ‚ç‚¹ï¼‰ï¼Œæ›´æ–°æˆåŠŸï¼Œè¯¥é‚»å±…èŠ‚ç‚¹åº”è¯¥åŠ å…¥ next_waveã€‚

> **ç¤ºä¾‹:**
>
> 1.  å‡è®¾é‚»å±…è·ç¦» dist[nidx] **åˆå§‹ä¸º 999** (\infty)ã€‚
> 2.  çº¿ç¨‹è®¡ç®— next_dist = 5ã€‚
> 3.  `atomicMin` è¿”å› **999**ã€‚ 5 < 999 ä¸º **True**ã€‚æ›´æ–°æˆåŠŸï¼Œdist[nidx] å˜ä¸º 5ã€‚

### 3. åŠ å…¥ä¸‹ä¸€æ³¢å‰ï¼ˆåŸå­æ“ä½œï¼‰

c
int loc = atomicAdd(next_wave_len, 1); // åŸå­åœ°å¢åŠ ä¸‹ä¸€æ³¢å‰é•¿åº¦
next_wave[2 * loc] = nx;
next_wave[2 * loc + 1] = ny;


  * **æœºåˆ¶:** atomicAdd(next_wave_len, 1) å®‰å…¨åœ°å¢åŠ äº†ä¸‹ä¸€æ³¢å‰çš„é•¿åº¦ã€‚å®ƒè¿”å› **å¢åŠ å‰** çš„é•¿åº¦ locï¼Œå³æ–°èŠ‚ç‚¹åœ¨ next_wave æ•°ç»„ä¸­çš„**èµ·å§‹å†™å…¥ä½ç½®**ã€‚
  * **å†™å…¥:** çº¿ç¨‹å°†æ–°èŠ‚ç‚¹ nx, ny) çš„åæ ‡å†™å…¥ next_wave æ•°ç»„ã€‚

> **ç¤ºä¾‹:**
>
> 1.  å‡è®¾ next_wave_len å½“å‰ä¸º 10ã€‚
> 2.  `atomicAdd` è¿”å› loc = 10ã€‚
> 3.  æ–°èŠ‚ç‚¹ nx, ny) è¢«å†™å…¥ next_wave[20] å’Œ next_wave[21]ã€‚

## ğŸ¯ æ€»ç»“

è¿™ä¸ª Kernel åˆ©ç”¨äº† GPU çš„å¤§è§„æ¨¡å¹¶è¡Œæ€§å’ŒåŸå­æ“ä½œï¼š

1.  **å¹¶è¡Œæ€§:** æ‰€æœ‰çº¿ç¨‹åŒæ—¶æ¢ç´¢å½“å‰æ³¢å‰ã€‚
2.  **`atomicMin`:** ç¡®ä¿æœ€çŸ­è·¯å¾„è·ç¦»çš„æ›´æ–°æ˜¯çº¿ç¨‹å®‰å…¨çš„ã€‚
3.  **`atomicAdd`:** ç¡®ä¿å¤šä¸ªçº¿ç¨‹å¯ä»¥å®‰å…¨åœ°å‘ä¸‹ä¸€æ³¢å‰æ·»åŠ æ–°èŠ‚ç‚¹ï¼Œè€Œä¸ä¼šç›¸äº’è¦†ç›–ã€‚


//--------------------------------------------------------------------------------------------------




//--------------------------------------------------------------------------------------------------
/*
question6:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œæœ‰ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

__global__ void map_inf_to_neg_kernel(int *grid, int rows, int cols) {
    const int i = threadIdx.x + blockIdx.x * blockDim.x;
    if (i >= rows * cols) return;
    if (grid[i] > rows * cols) grid[i] = -1;


answer:
è¿™æ®µä»£ç æ˜¯ä¸€ä¸ªéå¸¸ç®€æ´çš„ **CUDA Kernel**ï¼Œç”¨äºåœ¨å¹¶è¡Œå¹¿åº¦ä¼˜å…ˆæœç´¢ (BFS) ç»“æŸåè¿›è¡Œ**ç»“æœæ¸…ç†**ã€‚

å®ƒçš„æ ¸å¿ƒä½œç”¨æ˜¯ï¼š**å°†è·ç¦»æ•°ç»„ä¸­æ‰€æœ‰è¡¨ç¤ºâ€œä¸å¯è¾¾â€ï¼ˆå³åˆå§‹è®¾ç½®çš„æå¤§å€¼ï¼‰çš„å…ƒç´ ï¼Œç»Ÿä¸€ä¿®æ”¹ä¸º -1ã€‚**

-----

## âš™ï¸ I. æ ¸å¿ƒç›®æ ‡ï¼šç»“æœæ ‡å‡†åŒ–

### 1. èƒŒæ™¯ï¼šæœ€çŸ­è·¯å¾„è·ç¦»æ•°ç»„ (dist)

åœ¨ BFS ç®—æ³•ä¸­ï¼Œæˆ‘ä»¬é€šå¸¸å°†èµ·ç‚¹åˆ°æ‰€æœ‰ç‚¹çš„è·ç¦»æ•°ç»„ (dist) åˆå§‹åŒ–ä¸ºä¸€ä¸ª**æå¤§å€¼**ï¼ˆè¡¨ç¤ºæ— ç©·å¤§æˆ–ä¸å¯è¾¾ï¼‰ï¼Œç„¶ååœ¨æœç´¢è¿‡ç¨‹ä¸­æ›´æ–°è¿™äº›è·ç¦»ã€‚

  * **æå¤§å€¼ (\infty):** åœ¨æ‚¨çš„ `solve` å‡½æ•°ä¸­ï¼Œè¿™æ˜¯é€šè¿‡ `cudaMemset(dist, 0x63, ...)` è®¾ç½®çš„ã€‚`0x63` å¯¹åº”ä¸€ä¸ªå¾ˆå¤§çš„æ•´æ•°å€¼ã€‚
  * **ç›®æ ‡:** æœç´¢ç»“æŸåï¼Œä»»ä½•ä»ä¿æŒæå¤§å€¼çš„æ ¼å­éƒ½æ„å‘³ç€å®ƒ**ä¸å¯ä»èµ·ç‚¹åˆ°è¾¾**ã€‚æˆ‘ä»¬éœ€è¦å°†å…¶æ ‡è®°ä¸ºæ ‡å‡†çš„ **-1**ï¼ˆé€šå¸¸è¡¨ç¤ºä¸å¯è¾¾æˆ–æœªè®¿é—®ï¼‰ã€‚

### 2. Kernel çš„å®é™…ä½œç”¨

è™½ç„¶ Kernel ä¼ å…¥çš„å‚æ•°åæ˜¯ `grid`ï¼Œä½†æ ¹æ®å…¶åœ¨ `solve` å‡½æ•°ä¸­çš„è°ƒç”¨ä½ç½® (`map_inf_to_neg_kernel(dist, rows, cols);`)ï¼Œæˆ‘ä»¬å¯ä»¥ç¡®å®šå®ƒå®é™…æ“ä½œçš„æ˜¯ **dist æ•°ç»„**ã€‚

-----

## ğŸš€ II. æ‰§è¡Œæµç¨‹ä¸ç¤ºä¾‹

å‡è®¾æˆ‘ä»¬çš„ç½‘æ ¼æ˜¯ 4 * 4ï¼Œå…±æœ‰ rows * cols = 16 ä¸ªå…ƒç´ ã€‚

### 1. çº¿ç¨‹åˆ†å·¥ä¸ç´¢å¼•è®¡ç®—

c
const int i = threadIdx.x + blockIdx.x * blockDim.x;
if (i >= rows * cols) return;


  * **i:** çº¿ç¨‹çš„å…¨å±€ç´¢å¼•ï¼ŒèŒƒå›´ä» 0 åˆ° 15ã€‚æ¯ä¸ªçº¿ç¨‹ i è´Ÿè´£æ£€æŸ¥ dist æ•°ç»„ä¸­çš„ä¸€ä¸ªå…ƒç´ ã€‚
  * **è¾¹ç•Œæ£€æŸ¥:** ç¡®ä¿çº¿ç¨‹ä¸ä¼šè®¿é—®è¶…å‡º 4 * 4 åŒºåŸŸçš„å†…å­˜ã€‚

### 2. æ ¸å¿ƒæ¡ä»¶åˆ¤æ–­

c
if (grid[i] > rows * cols) grid[i] = -1;


  * **åˆ¤æ–­æ¡ä»¶:** grid[i]ï¼ˆå³ dist[i]ï¼‰æ˜¯å¦å¤§äº rows * cols (16)ã€‚
  * **åŸç†:** åœ¨ BFS åˆå§‹åŒ–æ—¶ï¼Œæˆ‘ä»¬å°†è·ç¦»è®¾ä¸ºä¸€ä¸ªéå¸¸å¤§çš„å€¼ï¼ˆä¾‹å¦‚å‡ äº¿ï¼‰ã€‚ä»»ä½•å¯è¾¾çš„è·ç¦»éƒ½è¿œå°äºç½‘æ ¼çš„æ€»å¤§å° (16)ã€‚å› æ­¤ï¼Œå¦‚æœ dist[i] > 16ï¼Œåˆ™å®ƒå¿…ç„¶æ˜¯é‚£ä¸ª**åˆå§‹çš„æå¤§å€¼**ï¼Œä»£è¡¨ä¸å¯è¾¾ã€‚

> **ç¤ºä¾‹:** å‡è®¾ä¸€ä¸ª Block è´Ÿè´£æ£€æŸ¥ç´¢å¼• 0 åˆ° 3 çš„å…ƒç´ ï¼š

| ç´¢å¼• i | åˆå§‹ dist[i] (GPU) | æ£€æŸ¥ (dist[i] > 16) | dist[i] çš„æœ€ç»ˆå€¼ | å«ä¹‰ |
| :--- | :--- | :--- | :--- | :--- |
| **0** | 3 (è·ç¦»èµ·ç‚¹ 3 æ­¥) | False (3 ä¸å¤§äº 16) | **3** | å¯è¾¾ |
| **1** | 12789 (æå¤§å€¼) | True | **-1** | ä¸å¯è¾¾ |
| **2** | 5 (è·ç¦»èµ·ç‚¹ 5 æ­¥) | False | **5** | å¯è¾¾ |
| **3** | 12789 (æå¤§å€¼) | True | **-1** | ä¸å¯è¾¾ |

**æ€»ç»“ï¼š** è¿™ä¸ª Kernel çš„æ•ˆç‡æé«˜ï¼Œå®ƒåˆ©ç”¨å¹¶è¡Œæ€§è®©æ‰€æœ‰çº¿ç¨‹åŒæ—¶æ‰§è¡Œä¸€ä¸ªç®€å•çš„é€»è¾‘åˆ¤æ–­ï¼Œå°†æ‰€æœ‰è¡¨ç¤ºâ€œæ— ç©·â€çš„è·ç¦»å€¼æ›¿æ¢ä¸ºç»Ÿä¸€çš„ **-1** æ ‡è®°ï¼Œæ–¹ä¾¿ä¸»æœºç«¯è¯»å–å’Œè§£é‡Šç»“æœã€‚


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question7:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    cudaMemcpy(result, dist + end_row * cols + end_col, sizeof(int), cudaMemcpyDeviceToDevice);

answer:
è¿™æ®µä»£ç æ˜¯ CUDA ä¸»æœºç«¯ï¼ˆCPUï¼‰ä»£ç ï¼Œç”¨äºä» GPU å†…å­˜ä¸­ï¼Œå°†æœ€ç»ˆè®¡ç®—å‡ºçš„ **ç»ˆç‚¹æœ€çŸ­è·ç¦»** å¤åˆ¶åˆ°è¾“å‡ºæŒ‡é’ˆ result æ‰€æŒ‡å‘çš„ä½ç½®ã€‚

-----

## âš™ï¸ I. æ ¸å¿ƒç›®çš„ï¼šæå–ç»ˆç‚¹è·ç¦»

æ•´ä¸ªå¹¶è¡Œ BFS ç®—æ³•åœ¨ `dist` æ•°ç»„ä¸­è®¡ç®—å‡ºäº†ä»èµ·ç‚¹åˆ°ç½‘æ ¼ä¸­æ¯ä¸ªç‚¹çš„æœ€çŸ­è·ç¦»ã€‚è¿™æ®µä»£ç æ˜¯**æå–**ç»ˆç‚¹ (end_row, end_col) è·ç¦»çš„æœ€åä¸€æ­¥ã€‚

### 1. å˜é‡å«ä¹‰

  * **result (ç›®æ ‡):** ä¸»æœºç«¯ä¼ å…¥çš„æŒ‡é’ˆï¼Œç”¨äºå­˜å‚¨æœ€ç»ˆçš„ç­”æ¡ˆï¼ˆä¸€ä¸ªæ•´æ•°ï¼‰ã€‚
  * **dist (æº):** GPU ä¸Šå­˜å‚¨æ‰€æœ‰æœ€çŸ­è·ç¦»çš„æ•°ç»„ã€‚
  * **end_row, end_col:** ç›®æ ‡ç»ˆç‚¹çš„åæ ‡ã€‚
  * **cols:** ç½‘æ ¼çš„åˆ—æ•° (Leading Dimension)ã€‚

## ğŸ”¢ II. ç´¢å¼•è®¡ç®—

åœ¨æ‰§è¡Œå†…å­˜æ‹·è´ä¹‹å‰ï¼Œéœ€è¦è®¡ç®—ç»ˆç‚¹ end_row, end_col) åœ¨ä¸€ç»´æ•°ç»„ dist ä¸­çš„ç²¾ç¡®ç´¢å¼•ã€‚

ç»ˆç‚¹ç´¢å¼• = end_row * cols + end_col

### ç¤ºä¾‹è§£é‡Š

å‡è®¾ç½‘æ ¼æ˜¯ 10 * 10ï¼Œæˆ‘ä»¬æƒ³æ‰¾åˆ°ç»ˆç‚¹ end_row=8, end_col=3) çš„æœ€çŸ­è·ç¦»ã€‚

  * cols = 10ã€‚
  * dist æ•°ç»„çš„èµ·å§‹åœ°å€æ˜¯ 0ã€‚

<!-- end list -->

1.  **è¡Œåç§»:** end_row * cols = 8 * 10 = 80ã€‚
      * è¿™è·³è¿‡äº†å‰ 8 è¡Œçš„æ•°æ®ã€‚
2.  **åˆ—åç§»:** + end_col = + 3ã€‚
3.  **ç»ˆç‚¹ç´¢å¼•:** 80 + 3 = 83ã€‚

**æºæŒ‡é’ˆ (`dist + index`):**
dist + end_row * cols + end_col = dist + 83

  * **å«ä¹‰:** `dist + 83` æ˜¯ GPU ä¸Š dist æ•°ç»„ä¸­ï¼Œç¬¬ 83 ä¸ªå…ƒç´ ï¼ˆå³ç»ˆç‚¹è·ç¦»ï¼‰çš„å†…å­˜åœ°å€ã€‚

## 3. å†…å­˜æ‹·è´

c
cudaMemcpy(result, dist + end_row * cols + end_col, sizeof(int), cudaMemcpyDeviceToDevice);


  * **ç›®æ ‡æŒ‡é’ˆ:** resultï¼ˆä¸€ä¸ª GPU å†…å­˜åœ°å€ï¼‰ã€‚
  * **æºåœ°å€:** dist + 83ï¼ˆGPU å†…å­˜ï¼‰ã€‚
  * **å¤§å°:** sizeof(int)ï¼ˆåªæ‹·è´ä¸€ä¸ªæ•´æ•°ï¼‰ã€‚
  * **æ–¹å‘:** cudaMemcpyDeviceToDevice (GPU åˆ° GPU)ã€‚

> **æ³¨æ„ï¼š** `result` å’Œ `dist` éƒ½æ˜¯ GPU å†…å­˜æŒ‡é’ˆã€‚å¦‚æœ `result` æ˜¯å‡½æ•°ç­¾åä¸­ä¼ å…¥çš„ GPU æŒ‡é’ˆï¼Œé‚£ä¹ˆæ–¹å‘å°±æ˜¯ DeviceToDeviceã€‚

**æ€»ç»“ï¼š** è¿™è¡Œä»£ç å°†è®¡ç®—å‡ºçš„æœ€çŸ­è·ç¦»å€¼ï¼ˆå­˜å‚¨åœ¨ dist æ•°ç»„çš„ç¬¬ 83 ä¸ªä½ç½®ï¼‰å¤åˆ¶åˆ° result æŒ‡é’ˆæ‰€æŒ‡å‘çš„ GPU å†…å­˜åœ°å€ï¼Œå®Œæˆæœ€ç»ˆè¾“å‡ºã€‚


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question8:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­



//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question10:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question11:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question12:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question13:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question14:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question15:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question16:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question17:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question18:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question19:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question20:


//--------------------------------------------------------------------------------------------------
