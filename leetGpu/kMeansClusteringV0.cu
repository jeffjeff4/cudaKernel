
#include <cuda_runtime.h>
#include <stdio.h>

#define VSIZE 4
#define MAX_KERNEL_SIZE 1000
#define MAX_TB 1024
#define BLOCK_THREADS 128
#define K_BLOCK_THREADS 128
#define MIN_DIFF .001

__constant__ float SHARED_KERNEL_X[MAX_KERNEL_SIZE];
__constant__ float SHARED_KERNEL_Y[MAX_KERNEL_SIZE];


__global__ void assign_label(
    const float* data_x, const float* data_y, int* labels,
    int sample_size, int k, int *changes,
    int *centroidCnts, float *centroidSums, int iteration
) {
    __shared__ float4 CENTROIDS[MAX_TB];
    __shared__ int CHANGES;
    int tx = threadIdx.x; int bx = blockIdx.x;
    if (tx == 0) CHANGES = 0;
    int txv = tx * VSIZE;
    int loc = VSIZE * blockDim.x * bx + txv;

    int ccs[VSIZE] = {0};
    float closest_value[VSIZE] = {INFINITY, INFINITY, INFINITY, INFINITY};
    float xy_values[VSIZE][2] = {0.0f};
    int local_labels[VSIZE] = {0};

    int within = loc < sample_size;

    if (within) {
        const int4 *ptr = reinterpret_cast<const int4*>(&labels[loc]);
        int4 value = ptr[0];
        local_labels[0] = value.x; local_labels[1] = value.y;
        local_labels[2] = value.z; local_labels[3] = value.w;

    }

    #pragma unroll
    for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++) {
        CENTROIDS[tx + i * BLOCK_THREADS] = (float4){0,0,0,0};
    }

    if (within) {
        const float4 *ptrX = reinterpret_cast<const float4*>(&data_x[loc]);
        const float4 *ptrY = reinterpret_cast<const float4*>(&data_y[loc]);
        float4 x4 = ptrX[0]; float4 y4 = ptrY[0];
        xy_values[0][0] = x4.x; xy_values[0][1] = y4.x;
        xy_values[1][0] = x4.y; xy_values[1][1] = y4.y;
        xy_values[2][0] = x4.z; xy_values[2][1] = y4.z;
        xy_values[3][0] = x4.w; xy_values[3][1] = y4.w;

        for (int i = 0; i < k; i++) {
            float cent_x = SHARED_KERNEL_X[i]; float cent_y = SHARED_KERNEL_Y[i];
            #pragma unroll
            for (int v = 0; v < VSIZE; v++) {
                if (loc + v >= sample_size) break;
                float diff_x = cent_x - xy_values[v][0];
                float diff_y = cent_y - xy_values[v][1];
                float euclid = diff_x * diff_x + diff_y * diff_y; 
                if (closest_value[v] - euclid > MIN_DIFF) {
                    closest_value[v] = euclid;
                    ccs[v] = i;
                }
            }
        }
    }

    __syncthreads();
    if (within) {
        if (loc + VSIZE <= sample_size) {
            int4 rel = {ccs[0], ccs[1], ccs[2], ccs[3]};
            #pragma unroll
            for (int i = 0; i < VSIZE; i++) {
                int idx = ccs[i];
                atomicAdd(&CENTROIDS[idx].x, xy_values[i][0]);
                atomicAdd(&CENTROIDS[idx].y, xy_values[i][1]);
                atomicAdd(&CENTROIDS[idx].z, 1);
            }
            *reinterpret_cast<int4*>(&labels[loc]) = rel;
        } else {
            #pragma unroll
            for (int j = 0; j < VSIZE; j++) {
                int cur_offset = loc + j;
                if (cur_offset >= sample_size) break;
                int idx = ccs[j];
                labels[cur_offset] = idx;
                atomicAdd(&CENTROIDS[idx].x, xy_values[j][0]);
                atomicAdd(&CENTROIDS[idx].y, xy_values[j][1]);
                atomicAdd(&CENTROIDS[idx].z, 1);
            }
        }
    }

    #pragma unroll
    for (int c = 0; c < VSIZE; c++) {
        if (local_labels[c] != ccs[c]) {
            CHANGES = 1;
            break;
        }
    }

    __syncthreads();

    if (tx == 0 && (CHANGES || iteration == 0)) {
        *changes = 1;
    }

    #pragma unroll
    for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++) {
        int offset = tx + i * BLOCK_THREADS;
        if (offset >= k) break;
        float4 rel4 = CENTROIDS[offset];
        if ((int)(rel4.z)) {
            int sum_off = 2 * offset;
            atomicAdd(&centroidCnts[offset], (int)(rel4.z));
            atomicAdd(&centroidSums[sum_off], rel4.x);
            atomicAdd(&centroidSums[sum_off + 1], rel4.y);
        }
    }
}


__global__ void reset_centroids(
    float* final_centroid_x, float* final_centroid_y,
    int *centroidCnts, float *centroidSums, int k
) {
    int bx = blockIdx.x;
    int tx = threadIdx.x;

    int i = bx * blockDim.x + tx;
    if (i >= k) return;

    int cnt = centroidCnts[i];
    if (!cnt) return;

    int offset = i * 2;
    float2 *ptr = reinterpret_cast<float2*>(&centroidSums[offset]);
    float2 sums = ptr[0];
    final_centroid_x[i] = sums.x / cnt;
    final_centroid_y[i] = sums.y / cnt;

}

// data_x, data_y, labels, initial_centroid_x, initial_centroid_y,
// final_centroid_x, final_centroid_y are device pointers 
extern "C" void solve(
    const float* data_x, const float* data_y, int* labels,
    float* initial_centroid_x, float* initial_centroid_y,
    float* final_centroid_x, float* final_centroid_y,
    int sample_size, int k, int max_iterations
) {

    float *centroidSums;
    int *centroidCnts, *changes;
    int cc_cnt_size = sizeof(int) * MAX_TB;
    int cc_sum_size = sizeof(float) * MAX_TB * 2;
    int change_size = 64 * sizeof(int);
    cudaMalloc(&centroidCnts, cc_cnt_size);
    cudaMalloc(&centroidSums, cc_sum_size);
    cudaMalloc(&changes, change_size);
    cudaMemset(changes, 0, change_size);

    int ksize = sizeof(float) * k;
    cudaMemcpy(final_centroid_x, initial_centroid_x, ksize, cudaMemcpyDeviceToDevice);
    cudaMemcpy(final_centroid_y, initial_centroid_y, ksize, cudaMemcpyDeviceToDevice);

    int coarse = BLOCK_THREADS * VSIZE;
    int blocks = (sample_size + coarse - 1) / coarse;
    int kblocks = (k + K_BLOCK_THREADS - 1) / K_BLOCK_THREADS;
    int hchanges = 0;

    for (int i = 0; i < max_iterations; i++) {
        cudaMemcpyToSymbol(SHARED_KERNEL_X, final_centroid_x, ksize, 0, cudaMemcpyDeviceToDevice);
        cudaMemcpyToSymbol(SHARED_KERNEL_Y, final_centroid_y, ksize, 0, cudaMemcpyDeviceToDevice);

        cudaMemset(centroidCnts, 0, cc_cnt_size);
        cudaMemset(centroidSums, 0, cc_sum_size);

        assign_label<<<blocks, BLOCK_THREADS>>>(
            data_x, data_y, labels,
            sample_size, k, &changes[i],
            centroidCnts, centroidSums, i
        );
        cudaMemcpy(&hchanges, &changes[i], sizeof(int), cudaMemcpyDeviceToHost);
        if (!hchanges) break;

        reset_centroids<<<kblocks, K_BLOCK_THREADS>>>(
            final_centroid_x, final_centroid_y,
            centroidCnts, centroidSums, k
        );

    }
}



//--------------------------------------------------------------------------------------------------
/*
question0:
ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

å¥½çš„ï¼Œè¿™æ®µ CUDA C++ ä»£ç å®ç°äº†å¹¶è¡ŒåŒ–çš„ **K-Means èšç±»ç®—æ³•ï¼ˆK-Means Clusteringï¼‰**ã€‚è¿™æ˜¯ä¸€ä¸ªç»å…¸çš„æ— ç›‘ç£å­¦ä¹ ç®—æ³•ï¼Œç”¨äºå°†æ•°æ®é›†ä¸­çš„æ ·æœ¬ç‚¹åˆ†æˆ k ä¸ªç°‡ï¼ˆClusterï¼‰ã€‚

ç”±äºä»£ç å¾ˆé•¿ï¼Œæˆ‘ä»¬å°†å…¶åˆ†ä¸ºä¸‰ä¸ªä¸»è¦éƒ¨åˆ†æ¥è§£é‡Šï¼š**å†…æ ¸ï¼ˆ`assign_label` å’Œ `reset_centroids`ï¼‰**ã€**æ•°æ®ç»“æ„**ä»¥åŠ**ä¸»æœºå‡½æ•°ï¼ˆ`solve`ï¼‰**ã€‚

## ğŸ§  1. K-Means ç®—æ³•æ ¸å¿ƒåŸç†

K-Means ç®—æ³•æ˜¯ä¸€ä¸ªè¿­ä»£è¿‡ç¨‹ï¼Œå…¶æ ¸å¿ƒæ­¥éª¤å°±æ˜¯åœ¨è¿™æ®µ CUDA ä»£ç ä¸­å¹¶è¡Œå®ç°çš„ï¼š

1.  **åˆ†é… (Assign)**ï¼šå°†æ¯ä¸ªæ•°æ®ç‚¹åˆ†é…ç»™**è·ç¦»æœ€è¿‘çš„**ä¸­å¿ƒç‚¹ï¼ˆCentroidï¼‰ã€‚
2.  **æ›´æ–° (Update)**ï¼šæ ¹æ®åˆ†é…ç»“æœï¼Œé‡æ–°è®¡ç®—æ¯ä¸ªç°‡çš„æ–°ä¸­å¿ƒç‚¹ï¼ˆå³æ‰€æœ‰ç°‡å†…ç‚¹çš„å¹³å‡å€¼ï¼‰ã€‚

ä»£ç ä¸­çš„ä¸¤ä¸ªå†…æ ¸å‡½æ•°åˆ†åˆ«å¯¹åº”è¿™ä¸¤ä¸ªæ­¥éª¤ï¼š

| æ­¥éª¤ | CUDA å†…æ ¸å‡½æ•° | æè¿° |
| :--- | :--- | :--- |
| **åˆ†é…** | `assign_label` | å¹¶è¡Œè®¡ç®—æ¯ä¸ªæ ·æœ¬ç‚¹åˆ° k ä¸ªä¸­å¿ƒç‚¹çš„è·ç¦»ï¼Œå¹¶è®°å½•ä¸‹æœ€è¿‘çš„ä¸­å¿ƒç‚¹ IDã€‚ |
| **æ›´æ–°** | `reset_centroids` | æ ¹æ®æ–°çš„åˆ†é…ç»“æœï¼Œè®¡ç®—æ¯ä¸ªç°‡çš„å¹³å‡ä½ç½®ï¼Œæ›´æ–°ä¸­å¿ƒç‚¹ã€‚ |

-----

## ğŸ’» 2. æ•°æ®ç»“æ„å’Œå†…å­˜åˆ†é…

è¿™æ®µä»£ç å……åˆ†åˆ©ç”¨äº† GPU çš„å„ç§å†…å­˜ç±»å‹æ¥æé«˜é€Ÿåº¦ã€‚

| å˜é‡/å†…å­˜ç±»å‹ | ä½œç”¨ | å­˜æ”¾å†…å®¹ |
| :--- | :--- | :--- |
| **`__constant__`** | **å¸¸é‡å†…å­˜**ï¼šç”¨äºå­˜å‚¨**ä¸­å¿ƒç‚¹**ã€‚æ‰€æœ‰çº¿ç¨‹å…±äº«ï¼Œåªè¯»ï¼Œé€Ÿåº¦å¿«ã€‚ | `SHARED_KERNEL_X`, `SHARED_KERNEL_Y`ï¼šæ‰€æœ‰ k ä¸ªä¸­å¿ƒç‚¹çš„ (x, y) åæ ‡ã€‚ |
| **`__shared__`** | **å…±äº«å†…å­˜**ï¼šç”¨äº Block å†…éƒ¨çš„å¿«é€Ÿä¸´æ—¶å­˜å‚¨ã€‚ | `CENTROIDS`ï¼šä¸´æ—¶å­˜å‚¨**æœ¬ Block** å‘ç°çš„ k ä¸ªä¸­å¿ƒç‚¹çš„**å±€éƒ¨æ±‚å’Œç»“æœ**ã€‚ |
| **å…¨å±€å†…å­˜ (Device)** | ç”¨äºå­˜å‚¨å¤§è§„æ¨¡æ•°æ®å’Œè¿­ä»£ç»“æœã€‚ | `data_x/y`ï¼ˆæ ·æœ¬ç‚¹åæ ‡ï¼‰ï¼Œ`labels`ï¼ˆæ¯ä¸ªç‚¹çš„ç°‡ IDï¼‰ï¼Œ`centroidCnts/Sums`ï¼ˆå…¨å±€ç´¯åŠ å™¨ï¼‰ã€‚ |
| **`VSIZE` (4)** | **å‘é‡åŒ–å¤§å°**ã€‚ä¸€ä¸ªçº¿ç¨‹ä¸€æ¬¡å¤„ç† 4 ä¸ªæ•°æ®ç‚¹ï¼Œæé«˜å†…å­˜è®¿é—®æ•ˆç‡ã€‚ |

-----

## ğŸš€ 3. å†…æ ¸å‡½æ•°è¯¦è§£

### A. `assign_label` å†…æ ¸ï¼ˆåˆ†é…æ­¥éª¤ï¼‰

è¿™ä¸ªå†…æ ¸æ˜¯ K-Means ç®—æ³•ä¸­æœ€è€—æ—¶çš„éƒ¨åˆ†ï¼Œå®ƒå°† N ä¸ªæ•°æ®ç‚¹åˆ†é…ç»™ k ä¸ªä¸­å¿ƒç‚¹ã€‚

#### 1\. åˆå§‹åŒ–å’Œå‘é‡åŒ–åŠ è½½

  * **å¹¶è¡Œç»“æ„**ï¼šæ¯ä¸ª CUDA çº¿ç¨‹è´Ÿè´£å¤„ç† **4 ä¸ª**ï¼ˆ`VSIZE`ï¼‰æ•°æ®ç‚¹ã€‚
  * **åŠ è½½æ ·æœ¬ç‚¹**ï¼šçº¿ç¨‹ tx ä»å…¨å±€å†…å­˜ä¸­ä¸€æ¬¡æ€§åŠ è½½å®ƒè¦å¤„ç†çš„ 4 ä¸ªæ ·æœ¬ç‚¹çš„ x å’Œ y åæ ‡åˆ°å±€éƒ¨æ•°ç»„ `xy_values` ä¸­ã€‚
  * **åŠ è½½æ ‡ç­¾**ï¼šåŒæ—¶å°†å½“å‰æ ‡ç­¾ `labels[loc]` åŠ è½½åˆ° `local_labels` ä¸­ï¼Œç”¨äºç¨åæ£€æŸ¥æ˜¯å¦æœ‰å˜åŒ–ã€‚

#### 2\. è·ç¦»è®¡ç®—ï¼ˆå…³é”®æ­¥éª¤ï¼‰

c
        for (int i = 0; i < k; i++) 
            float cent_x = SHARED_KERNEL_X[i]; // ä»å¸¸é‡å†…å­˜è¯»å–ä¸­å¿ƒç‚¹åæ ‡
            // ...
            #pragma unroll
            for (int v = 0; v < VSIZE; v++) 
                // ...
                float euclid = diff_x * diff_x + diff_y * diff_y; // æ¬§æ°è·ç¦»å¹³æ–¹
                if (closest_value[v] - euclid > MIN_DIFF) 
                    closest_value[v] = euclid;
                    ccs[v] = i; // è®°å½•æœ€è¿‘çš„ä¸­å¿ƒç‚¹ ID (i)
                }
            }
        }


  * **å¾ªç¯**ï¼šæ¯ä¸ªçº¿ç¨‹å¾ªç¯éå†æ‰€æœ‰ k ä¸ªä¸­å¿ƒç‚¹ã€‚
  * **å‘é‡åŒ–**ï¼š`#pragma unroll` å’Œå†…å±‚ `v` å¾ªç¯ç¡®ä¿ä¸€ä¸ªçº¿ç¨‹åŒæ—¶ä¸º 4 ä¸ªæ ·æœ¬ç‚¹è®¡ç®—è·ç¦»ã€‚
  * **æ¬§æ°è·ç¦»**ï¼šä½¿ç”¨**æ¬§æ°è·ç¦»çš„å¹³æ–¹**ï¼ˆ`diff_x * diff_x + diff_y * diff_y`ï¼‰æ¥é¿å…è€—æ—¶çš„å¹³æ–¹æ ¹è®¡ç®—ã€‚
  * **ç»“æœ**ï¼š`ccs` æ•°ç»„å­˜å‚¨äº†è¿™ 4 ä¸ªæ ·æœ¬ç‚¹åº”è¯¥å½’å±çš„æ–°ç°‡ IDã€‚

#### 3\. å±€éƒ¨ç´¯åŠ å’Œå†™å›

çº¿ç¨‹æ‰¾åˆ°æ–°ç°‡ ID åï¼Œéœ€è¦æ›´æ–°ç°‡çš„æ±‚å’Œç»“æœï¼š

c
            for (int i = 0; i < VSIZE; i++) 
                int idx = ccs[i]; // æ–°ç°‡ ID
                atomicAdd(&CENTROIDS[idx].x, xy_values[i][0]); // å±€éƒ¨ç´¯åŠ  X
                atomicAdd(&CENTROIDS[idx].y, xy_values[i][1]); // å±€éƒ¨ç´¯åŠ  Y
                atomicAdd(&CENTROIDS[idx].z, 1); // å±€éƒ¨ç´¯åŠ è®¡æ•°
            }
            *reinterpret_cast<int4*>(&labels[loc]) = rel; // å†™å›æ–°æ ‡ç­¾


  * **`atomicAdd`**ï¼šä½¿ç”¨åŸå­æ“ä½œï¼Œç¡®ä¿å½“ Block å†…å¤šä¸ªçº¿ç¨‹åŒæ—¶æƒ³æ›´æ–°åŒä¸€ä¸ªä¸­å¿ƒç‚¹ï¼ˆ`CENTROIDS[idx]`ï¼‰çš„å±€éƒ¨æ±‚å’Œæ—¶ï¼Œæ•°æ®ä¸ä¼šå‡ºé”™ã€‚è¿™ä¸ªæ±‚å’Œå‘ç”Ÿåœ¨**å…±äº«å†…å­˜** `CENTROIDS` ä¸­ã€‚
  * **æ›´æ–°æ ‡ç­¾**ï¼šå°†æ–°çš„ç°‡ ID (`ccs`) å†™å›å…¨å±€å†…å­˜ä¸­çš„ `labels` æ•°ç»„ã€‚

#### 4\. æ£€æŸ¥å˜åŒ–å’Œå…¨å±€ç´¯åŠ 

  * **æ£€æŸ¥å˜åŒ–**ï¼šé€šè¿‡æ¯”è¾ƒ `local_labels`ï¼ˆæ—§æ ‡ç­¾ï¼‰å’Œ `ccs`ï¼ˆæ–°æ ‡ç­¾ï¼‰ï¼Œå¦‚æœä»»ä½•ä¸€ä¸ªæ ·æœ¬ç‚¹çš„å½’å±å‘ç”Ÿå˜åŒ–ï¼Œåˆ™è®¾ç½® `CHANGES = 1`ã€‚çº¿ç¨‹ 0 ä¼šå°†è¿™ä¸ªå˜åŒ–çŠ¶æ€å†™å…¥å…¨å±€å†…å­˜ `changes`ã€‚
  * **å…¨å±€ç´¯åŠ **ï¼šæœ€åï¼Œæ¯ä¸ª Block å°†å…¶åœ¨ `CENTROIDS` ä¸­è®¡ç®—å‡ºçš„**å±€éƒ¨æ±‚å’Œ**ï¼Œä½¿ç”¨åŸå­æ“ä½œç´¯åŠ åˆ°å…¨å±€å†…å­˜ `centroidCnts` å’Œ `centroidSums` ä¸­ã€‚

### B. `reset_centroids` å†…æ ¸ï¼ˆæ›´æ–°æ­¥éª¤ï¼‰

è¿™ä¸ªå†…æ ¸æ˜¯ K-Means ç®—æ³•çš„ç¬¬äºŒæ­¥ï¼Œè®¡ç®—æ–°çš„ä¸­å¿ƒç‚¹ä½ç½®ã€‚

  * **å¹¶è¡Œç»“æ„**ï¼šæ¯ä¸ªçº¿ç¨‹è´Ÿè´£è®¡ç®—**ä¸€ä¸ª**ä¸­å¿ƒç‚¹ i çš„æ–°åæ ‡ã€‚
  * **è®¡ç®—å¹³å‡å€¼**ï¼š
    1.  çº¿ç¨‹ i è¯»å–å…¨å±€ç´¯åŠ å™¨ `centroidCnts[i]`ï¼ˆç°‡ i çš„æ ·æœ¬æ€»æ•°ï¼‰ã€‚
    2.  è¯»å–å…¨å±€ç´¯åŠ å™¨ `centroidSums` ä¸­ç°‡ i çš„ X å’Œ Y åæ ‡æ€»å’Œã€‚
    3.  æ–°åæ ‡ = **æ€»å’Œ / æ€»æ•°**ã€‚
  * **å†™å›**ï¼šå°†æ–°çš„ä¸­å¿ƒç‚¹åæ ‡å†™å…¥ `final_centroid_x[i]` å’Œ `final_centroid_y[i]`ã€‚

-----

## ğŸ¬ 4. ä¸»æœºå‡½æ•° `solve` è¯¦è§£ï¼ˆè¿­ä»£æ§åˆ¶ï¼‰

`solve` å‡½æ•°æ˜¯æ•´ä¸ªç®—æ³•çš„æ§åˆ¶ä¸­å¿ƒã€‚

1.  **å†…å­˜åˆ†é…**ï¼šåœ¨ GPU ä¸Šåˆ†é… `centroidCnts` å’Œ `centroidSums` æ•°ç»„ï¼Œç”¨äºå…¨å±€ç´¯åŠ ã€‚
2.  **è¿­ä»£å¾ªç¯**ï¼š`for (int i = 0; i < max_iterations; i++)`
      * **ä¼ è¾“ä¸­å¿ƒç‚¹**ï¼šå°†ä¸Šä¸€æ¬¡è¿­ä»£å¾—åˆ°çš„ä¸­å¿ƒç‚¹ (`final_centroid_x/y`) å¤åˆ¶åˆ°å¿«é€Ÿçš„**å¸¸é‡å†…å­˜** (`SHARED_KERNEL_X/Y`) ä¸­ï¼Œä¾› `assign_label` å†…æ ¸ä½¿ç”¨ã€‚
      * **æ¸…é›¶ç´¯åŠ å™¨**ï¼šå°† `centroidCnts` å’Œ `centroidSums` é‡ç½®ä¸º 0ã€‚
      * **å¯åŠ¨ `assign_label`**ï¼šæ‰§è¡Œåˆ†é…æ­¥éª¤ã€‚
      * **æ£€æŸ¥åœæ­¢æ¡ä»¶**ï¼šå°† `changes` æ ‡å¿—ä» GPU å¤åˆ¶åˆ° CPU å˜é‡ `hchanges`ã€‚å¦‚æœ `hchanges` ä¸º 0ï¼ˆ**æ²¡æœ‰æ ·æœ¬ç‚¹çš„å½’å±å‘ç”Ÿå˜åŒ–**ï¼‰ï¼Œåˆ™ K-Means ç®—æ³•æ”¶æ•›ï¼Œå¾ªç¯ `break`ã€‚
      * **å¯åŠ¨ `reset_centroids`**ï¼šæ‰§è¡Œæ›´æ–°æ­¥éª¤ï¼Œè®¡ç®—æ–°çš„ä¸­å¿ƒç‚¹ã€‚

é€šè¿‡è¿™ç§å¹¶è¡ŒåŒ–ï¼ŒCUDA K-Means ç®—æ³•åœ¨ GPU ä¸Šå¯ä»¥æ¯” CPU æ›´å¿«åœ°å®Œæˆå¤§é‡çš„è·ç¦»è®¡ç®—å’Œæ±‚å’Œæ“ä½œï¼Œå®ç°é«˜æ•ˆèšç±»ã€‚


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question1:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question2:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    int coarse = BLOCK_THREADS * VSIZE;
    int blocks = (sample_size + coarse - 1) / coarse;
    int kblocks = (k + K_BLOCK_THREADS - 1) / K_BLOCK_THREADS;
    int hchanges = 0;

å¥½çš„ï¼Œè¿™æ®µä»£ç æ˜¯ CUDA ä¸»æœºä»£ç ä¸­è®¡ç®—**å¹¶è¡Œå¯åŠ¨å‚æ•°**çš„éƒ¨åˆ†ã€‚å®ƒå†³å®šäº†è¦å¯åŠ¨å¤šå°‘ä¸ª GPU çº¿ç¨‹ç»„ï¼ˆå³ Blockï¼‰æ‰èƒ½è¦†ç›–æ‰€æœ‰çš„æ•°æ®å¤„ç†ä»»åŠ¡ã€‚

æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ª**æŠ«è¨åº—è®¢å•**çš„æ¯”å–»æ¥è§£é‡Šè¿™ä¸ª\*\*å‘ä¸Šå–æ•´ï¼ˆCeiling Divisionï¼‰\*\*çš„è®¡ç®—æ–¹æ³•ã€‚

-----

## ğŸ• 1. è®¡ç®— Block çš„æ€»æ•°é‡ (Grid Size)

åœ¨ CUDA ä¸­ï¼Œæˆ‘ä»¬ä¸èƒ½ä¿è¯ Block çš„æ•°é‡åˆšå¥½èƒ½æ•´é™¤ä»»åŠ¡é‡ã€‚å› æ­¤ï¼Œæˆ‘ä»¬æ€»æ˜¯éœ€è¦**å‘ä¸Šå–æ•´**ï¼Œç¡®ä¿æœ€åä¸€ä¸ª Block èƒ½å¤Ÿå¤„ç†å‰©ä½™çš„æ‰€æœ‰ä»»åŠ¡ã€‚

è®¡ç®— Block æ•°é‡çš„é€šç”¨å…¬å¼ï¼ˆåœ¨æ•´æ•°è¿ç®—ä¸­å®ç°å‘ä¸Šå–æ•´ï¼‰æ˜¯ï¼š

\textBlocks} = \lceil \frac\textä»»åŠ¡æ€»æ•°}}\textæ¯ä¸ª Block å¤„ç†çš„ä»»åŠ¡æ•°}} \rceil = \frac\textä»»åŠ¡æ€»æ•°} + \textåˆ†å—å¤§å°} - 1}\textåˆ†å—å¤§å°}

è¿™æ®µä»£ç è®¡ç®—äº†ä¸¤ç§ä¸åŒçš„ Block æ•°é‡ï¼šä¸€ç§æ˜¯ç”¨äºå¤„ç†**æ ·æœ¬ç‚¹**ï¼Œå¦ä¸€ç§æ˜¯ç”¨äºå¤„ç†**ä¸­å¿ƒç‚¹**ã€‚

-----

## ğŸ› ï¸ 2. ä»£ç è¯¦è§£ä¸ä¾‹å­

### A. è®¡ç®— `coarse`ï¼ˆæ¯ä¸ª Block å¤„ç†çš„æ ·æœ¬ç‚¹æ€»æ•°ï¼‰

c
int coarse = BLOCK_THREADS * VSIZE;


  * **å«ä¹‰**ï¼š`coarse` æ˜¯ä¸€ä¸ª Block åœ¨ä¸€æ¬¡æ“ä½œä¸­èƒ½å¤Ÿå¤„ç†çš„**æ ·æœ¬ç‚¹**ï¼ˆæ•°æ®ç‚¹ï¼‰çš„æ€»æ•°ã€‚
  * **å‚æ•°**ï¼š
      * `BLOCK_THREADS`ï¼šæ¯ä¸ª Block æœ‰ 128 ä¸ªçº¿ç¨‹ã€‚
      * `VSIZE`ï¼šæ¯ä¸ªçº¿ç¨‹ä¸€æ¬¡å¤„ç† 4 ä¸ªæ ·æœ¬ç‚¹ï¼ˆå‘é‡åŒ–ï¼‰ã€‚
  * **ä¾‹å­**ï¼šå¦‚æœ `BLOCK_THREADS = 128`ï¼Œ`VSIZE = 4`ã€‚
    \textcoarse} = 128 * 4 = 512
      * ç»“è®ºï¼šä¸€ä¸ª Block å¯ä»¥å¹¶è¡Œå¤„ç† **512 ä¸ª**æ ·æœ¬ç‚¹ã€‚

### B. è®¡ç®— `blocks`ï¼ˆå¤„ç†æ ·æœ¬ç‚¹çš„ Block æ•°é‡ï¼‰

c
int blocks = (sample_size + coarse - 1) / coarse;


  * **å«ä¹‰**ï¼š`blocks` æ˜¯å¯åŠ¨ `assign_label` å†…æ ¸æ‰€éœ€çš„ Block æ€»æ•°ã€‚è¿™æ˜¯ K-Means ç®—æ³•ä¸­å¤„ç†**æ ·æœ¬ç‚¹**æ‰€éœ€çš„å¹¶è¡Œåº¦ã€‚
  * **å‚æ•°**ï¼š
      * `sample_size`ï¼šæ ·æœ¬ç‚¹çš„æ€»æ•°ï¼ˆä»»åŠ¡æ€»æ•°ï¼‰ã€‚
      * `coarse`ï¼šæ¯ä¸ª Block å¤„ç† 512 ä¸ªæ ·æœ¬ç‚¹ï¼ˆåˆ†å—å¤§å°ï¼‰ã€‚

#### ä¾‹å­ï¼šå¤„ç† N=2200 ä¸ªæ ·æœ¬ç‚¹

å‡è®¾ `sample_size = 2200`ï¼Œ`coarse = 512`ã€‚

1.  **ç›´æ¥é™¤æ³•ï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼š** 2200 / 512 \approx 4.29ã€‚å¦‚æœåªå¯åŠ¨ 4 ä¸ª Blockï¼Œé‚£ä¹ˆ 4 * 512 = 2048 ä¸ªæ ·æœ¬ç‚¹ä¼šè¢«å¤„ç†ï¼Œè¿˜å‰©ä¸‹ 2200 - 2048 = 152 ä¸ªæ ·æœ¬ç‚¹ä¼šè¢«é—æ¼ã€‚
2.  **å‘ä¸Šå–æ•´è®¡ç®—ï¼š**
    \textblocks} = \frac2200 + 512 - 1}512} = \frac2711}512} = 5
      * ç»“è®ºï¼šéœ€è¦å¯åŠ¨ **5 ä¸ª Block**ã€‚
      * ç¬¬ 5 ä¸ª Block ä¼šå¤„ç†å‰©ä½™çš„ 152 ä¸ªæ ·æœ¬ç‚¹ï¼Œç¡®ä¿æ‰€æœ‰æ•°æ®éƒ½è¢«è¦†ç›–ã€‚

### C. è®¡ç®— `kblocks`ï¼ˆå¤„ç†ä¸­å¿ƒç‚¹çš„ Block æ•°é‡ï¼‰

c
int kblocks = (k + K_BLOCK_THREADS - 1) / K_BLOCK_THREADS;


  * **å«ä¹‰**ï¼š`kblocks` æ˜¯å¯åŠ¨ `reset_centroids` å†…æ ¸æ‰€éœ€çš„ Block æ€»æ•°ã€‚è¿™æ˜¯ K-Means ç®—æ³•ä¸­å¤„ç† **k ä¸ªä¸­å¿ƒç‚¹**æ‰€éœ€çš„å¹¶è¡Œåº¦ã€‚
  * **å‚æ•°**ï¼š
      * kï¼šä¸­å¿ƒç‚¹çš„æ€»æ•°ï¼ˆä»»åŠ¡æ€»æ•°ï¼‰ã€‚
      * `K_BLOCK_THREADS`ï¼šæ¯ä¸ª Block æœ‰ 128 ä¸ªçº¿ç¨‹ï¼ˆæ¯ä¸ªçº¿ç¨‹å¤„ç†ä¸€ä¸ªä¸­å¿ƒç‚¹ï¼Œæ‰€ä»¥ Block å¤§å°ä¸º 128ï¼‰ã€‚

#### ä¾‹å­ï¼šå¤„ç† k=300 ä¸ªä¸­å¿ƒç‚¹

å‡è®¾ k = 300ï¼Œ\`K\_BLOCK\_THREADS = 128ã€‚

1.  **ç›´æ¥é™¤æ³•ï¼ˆå‘ä¸‹å–æ•´ï¼‰ï¼š** 300 / 128 \approx 2.34ã€‚å¦‚æœåªå¯åŠ¨ 2 ä¸ª Blockï¼Œé‚£ä¹ˆ 2 * 128 = 256 ä¸ªä¸­å¿ƒç‚¹ä¼šè¢«å¤„ç†ï¼Œå‰©ä¸‹ 44 ä¸ªä¸­å¿ƒç‚¹ä¼šè¢«é—æ¼ã€‚
2.  **å‘ä¸Šå–æ•´è®¡ç®—ï¼š**
    \textkblocks} = \frac300 + 128 - 1}128} = \frac427}128} = 3
      * ç»“è®ºï¼šéœ€è¦å¯åŠ¨ **3 ä¸ª Block**ã€‚
      * ç¬¬ 3 ä¸ª Block ä¼šå¯åŠ¨ 128 ä¸ªçº¿ç¨‹ï¼Œå…¶ä¸­åªæœ‰å‰ 44 ä¸ªçº¿ç¨‹ä¼šè®¡ç®—å‰©ä½™çš„ 44 ä¸ªä¸­å¿ƒç‚¹ï¼Œç¡®ä¿æ‰€æœ‰ k ä¸ªä¸­å¿ƒç‚¹éƒ½è¢«æ›´æ–°ã€‚

### D. `hchanges`ï¼ˆCPU å˜é‡ï¼‰

c
int hchanges = 0;


  * **å«ä¹‰**ï¼š`hchanges` æ˜¯ä¸€ä¸ªç®€å•çš„ **CPU å˜é‡**ï¼ˆä¸»æœºå˜é‡ï¼‰ã€‚
  * **ä½œç”¨**ï¼šåœ¨è¿­ä»£å¾ªç¯ä¸­ï¼Œå®ƒå°†ç”¨äºæ¥æ”¶ä» GPU å†…å­˜ `changes[i]` å¤åˆ¶å›æ¥çš„**æ”¶æ•›æ ‡å¿—**ã€‚
  * å¦‚æœ `hchanges` ä¸º 0ï¼Œè¡¨ç¤º K-Means ç®—æ³•æ”¶æ•›ï¼›å¦‚æœä¸º 1ï¼Œè¡¨ç¤ºéœ€è¦è¿›è¡Œä¸‹ä¸€è½®è¿­ä»£ã€‚

è¿™æ®µä»£ç çš„æ ¸å¿ƒç›®æ ‡å°±æ˜¯ç²¾ç¡®åœ°è®¡ç®—å‡ºå¯åŠ¨ Block çš„æ•°é‡ï¼Œä»¥ç¡®ä¿æ—¢èƒ½**å……åˆ†åˆ©ç”¨ GPU çš„å¹¶è¡Œæ€§**ï¼Œåˆèƒ½**å®Œæ•´åœ°è¦†ç›–æ‰€æœ‰çš„æ•°æ®ç‚¹å’Œä¸­å¿ƒç‚¹**ã€‚

//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question3:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

__global__ void assign_label(
    const float* data_x, const float* data_y, int* labels,
    int sample_size, int k, int *changes,
    int *centroidCnts, float *centroidSums, int iteration
) 

}

answer:
å¥½çš„ï¼Œè¿™æ®µ CUDA **å†…æ ¸ä»£ç  `assign_label`** å®ç°äº† **K-Means èšç±»ç®—æ³•**çš„ç¬¬ä¸€ä¸ªæ ¸å¿ƒæ­¥éª¤ï¼š**å¹¶è¡Œåˆ†é…ï¼ˆAssignï¼‰**ã€‚

è¿™ä¸ªå†…æ ¸çš„ä»»åŠ¡æ˜¯è®© GPU ä¸Šçš„æ¯ä¸ªçº¿ç¨‹å¹¶è¡Œåœ°æ‰§è¡Œä»¥ä¸‹å·¥ä½œï¼š

1.  è¯»å–å®ƒè´Ÿè´£çš„**æ ·æœ¬ç‚¹**ï¼ˆæ•°æ®ï¼‰ã€‚
2.  è®¡ç®—è¿™äº›æ ·æœ¬ç‚¹åˆ°**æ‰€æœ‰** k ä¸ª**ä¸­å¿ƒç‚¹**çš„è·ç¦»ã€‚
3.  å°†æ ·æœ¬ç‚¹åˆ†é…ç»™**è·ç¦»æœ€è¿‘çš„**ä¸­å¿ƒç‚¹ã€‚
4.  è®°å½•è¿™æ¬¡åˆ†é…æ˜¯å¦å¯¼è‡´ä»»ä½•æ ·æœ¬ç‚¹çš„**ç°‡æ ‡ç­¾å‘ç”Ÿå˜åŒ–**ï¼ˆæ”¶æ•›æ£€æŸ¥ï¼‰ã€‚
5.  å°†è®¡ç®—ç»“æœï¼ˆç°‡å†…ç‚¹çš„æ€»å’Œä¸è®¡æ•°ï¼‰**ç´¯åŠ **èµ·æ¥ï¼Œä¾›ä¸‹ä¸€æ­¥æ›´æ–°ä¸­å¿ƒç‚¹ä½¿ç”¨ã€‚

æˆ‘ä»¬å°†ç”¨ä¸€ä¸ª**å·¥å‚è´¨é‡æ£€æµ‹**çš„æ¯”å–»æ¥è§£é‡Šè¿™æ®µå¤æ‚çš„ä»£ç æ˜¯å¦‚ä½•å®ç°é«˜æ•ˆå¹¶è¡Œçš„ã€‚

-----

## ğŸ­ 1. æ ¸å¿ƒæ€æƒ³ï¼šå‘é‡åŒ–ä¸å¹¶è¡Œè·ç¦»è®¡ç®—

### A. çº¿ç¨‹çš„èº«ä»½ä¸ä»»åŠ¡

  * **å¹¶è¡Œç»“æ„**ï¼šè¿™æ®µä»£ç é‡‡ç”¨äº† **VSIZE å‘é‡åŒ–**ã€‚`VSIZE` (é€šå¸¸ä¸º 4) æ„å‘³ç€ **ä¸€ä¸ªçº¿ç¨‹** åœ¨ä¸€æ¬¡æ“ä½œä¸­è´Ÿè´£å¤„ç† **4 ä¸ª** æ ·æœ¬ç‚¹çš„æ•°æ®ã€‚
  * **å…¨å±€ä½ç½®**ï¼š
    c
    int tx = threadIdx.x; int bx = blockIdx.x;
    int txv = tx * VSIZE;
    int loc = VSIZE * blockDim.x * bx + txv; // å…¨å±€èµ·å§‹ç´¢å¼•
    
      * **loc** è®¡ç®—äº†å½“å‰çº¿ç¨‹è´Ÿè´£çš„ **4 ä¸ª** æ ·æœ¬ç‚¹åœ¨æ•´ä¸ªæ•°æ®é›†ä¸­çš„èµ·å§‹ç´¢å¼•ã€‚
  * **å˜åŒ–æ ‡å¿—**ï¼š
    c
    __shared__ int CHANGES; // å…±äº«å†…å­˜ï¼Œç”¨äºæ ‡è®°æœ¬ Block æ˜¯å¦æœ‰å˜åŒ–
    if (tx == 0) CHANGES = 0; // åªæœ‰çº¿ç¨‹ 0 åˆå§‹åŒ–ä¸º 0
    
      * åœ¨ Block å†…éƒ¨ï¼Œ`CHANGES` æ˜¯ä¸€ä¸ªå…±äº«å˜é‡ï¼Œç”¨äºå¿«é€Ÿåˆ¤æ–­**è¿™ä¸ª Block** å¤„ç†çš„æ ·æœ¬ç‚¹æœ‰æ²¡æœ‰æ”¹å˜å½’å±ã€‚

### B. æ•°æ®åŠ è½½ä¸åˆå§‹åŒ–

c
    // ...
    int within = loc < sample_size; 
    
    if (within) 
        // ... (1) ä»å…¨å±€å†…å­˜ labels[] åŠ è½½æ—§æ ‡ç­¾åˆ° local_labels[]
    }
    // ... (2) æ¸…é›¶å…±äº«å†…å­˜ CENTROIDS[]
    
    if (within) 
        // ... (3) ä»å…¨å±€å†…å­˜ data_x/y åŠ è½½ 4 ä¸ªæ ·æœ¬ç‚¹çš„åæ ‡åˆ° xy_values[][]
    }


  * **`within`** æ£€æŸ¥ï¼šç”±äº Block å¯åŠ¨æ•°é‡æ˜¯å‘ä¸Šå–æ•´çš„ï¼Œæœ‰äº›çº¿ç¨‹å¯èƒ½è½åœ¨æœ‰æ•ˆæ ·æœ¬ç‚¹ä¹‹å¤–ï¼Œ`within` ç¡®ä¿åªæœ‰è´Ÿè´£çœŸå®æ•°æ®çš„çº¿ç¨‹æ‰è¿›è¡Œè®¡ç®—ã€‚
  * **æ—§æ ‡ç­¾åŠ è½½**ï¼šçº¿ç¨‹å¹¶è¡Œåœ°å°†å®ƒè´Ÿè´£çš„ 4 ä¸ªæ ·æœ¬ç‚¹çš„æ—§æ ‡ç­¾ (`labels`) åŠ è½½åˆ°æœ¬åœ°æ•°ç»„ `local_labels` ä¸­ï¼Œç”¨äºæ”¶æ•›æ£€æŸ¥ã€‚
  * **æ ·æœ¬ç‚¹åŠ è½½**ï¼šä½¿ç”¨ `float4` å’Œ `reinterpret_cast`ï¼Œä¸€ä¸ªçº¿ç¨‹é«˜æ•ˆåœ°ä»å…¨å±€å†…å­˜ä¸­è¯»å–å®ƒè´Ÿè´£çš„ 4 ä¸ªæ ·æœ¬ç‚¹çš„ (x, y) åæ ‡ï¼Œå¹¶å­˜å…¥æœ¬åœ°çš„ `xy_values` æ•°ç»„ã€‚

-----

## ğŸ“ 2. è·ç¦»è®¡ç®—å’Œåˆ†é…ï¼ˆæ ¸å¿ƒé€»è¾‘ï¼‰

è¿™ä¸€é˜¶æ®µæ˜¯ç®—æ³•çš„ä¸»ä½“ï¼šæ‰¾åˆ°æ¯ä¸ªæ ·æœ¬ç‚¹è·ç¦»æœ€è¿‘çš„ä¸­å¿ƒç‚¹ã€‚

c
        for (int i = 0; i < k; i++) 
            float cent_x = SHARED_KERNEL_X[i]; // ä»å¸¸é‡å†…å­˜è¯»å–ç¬¬ i ä¸ªä¸­å¿ƒç‚¹
            
            #pragma unroll
            for (int v = 0; v < VSIZE; v++)  // éå†çº¿ç¨‹è´Ÿè´£çš„ 4 ä¸ªæ ·æœ¬ç‚¹
                // ...
                float diff_x = cent_x - xy_values[v][0];
                float euclid = diff_x * diff_x + diff_y * diff_y; // æ¬§æ°è·ç¦»å¹³æ–¹
                
                if (closest_value[v] - euclid > MIN_DIFF) 
                    closest_value[v] = euclid; // æ‰¾åˆ°æ›´è¿‘çš„è·ç¦»
                    ccs[v] = i;              // è®°å½•æ–°çš„ç°‡ ID
                }
            }
        }


> **æ¯”å–»ï¼šå·¥å‚è´¨é‡æ£€æµ‹**
> å‡è®¾ k ä¸ªä¸­å¿ƒç‚¹æ˜¯ k ä¸ª**ä¸åŒçš„è´¨é‡æ ‡å‡†**ã€‚ä¸€ä¸ªçº¿ç¨‹è´Ÿè´£ 4 ä¸ªäº§å“ï¼ˆæ ·æœ¬ç‚¹ï¼‰ã€‚
>
> 1.  **å¤–å±‚å¾ªç¯ (`i`)**ï¼šçº¿ç¨‹éå†æ‰€æœ‰çš„ k ä¸ªè´¨é‡æ ‡å‡†ã€‚
> 2.  **å†…å±‚å¾ªç¯ (`v`)**ï¼šçº¿ç¨‹æ£€æŸ¥å®ƒè´Ÿè´£çš„ 4 ä¸ªäº§å“ï¼Œè®¡ç®—æ¯ä¸ªäº§å“ä¸å½“å‰æ ‡å‡† i çš„**ä¸åˆæ ¼åº¦ï¼ˆè·ç¦»ï¼‰**ã€‚
> 3.  **åˆ†é…**ï¼šå¦‚æœå½“å‰æ ‡å‡† i çš„ä¸åˆæ ¼åº¦ï¼ˆ`euclid`ï¼‰æ¯”ä¹‹å‰æ‰¾åˆ°çš„ä»»ä½•æ ‡å‡†éƒ½ä½ï¼ˆæ›´è¿‘ï¼‰ï¼Œé‚£ä¹ˆè¿™ä¸ªäº§å“å°±è¢«åˆ†é…ç»™æ ‡å‡† iï¼Œå¹¶è®°å½•åœ¨ `ccs` æ•°ç»„ä¸­ã€‚

-----

## ğŸ’¾ 3. ç»“æœç´¯åŠ å’Œå†™å›

åœ¨è®¡ç®—å®Œ 4 ä¸ªæ ·æœ¬ç‚¹çš„æ–°å½’å±åï¼Œçº¿ç¨‹éœ€è¦æ›´æ–°ç°‡çš„ç»Ÿè®¡ä¿¡æ¯ï¼Œå¹¶å†™å›ç»“æœã€‚

c
    __syncthreads(); // ç¡®ä¿æ‰€æœ‰çº¿ç¨‹éƒ½å®Œæˆäº†è·ç¦»è®¡ç®—
    if (within) 
        // ... (å¤„ç†è¾¹ç•Œæ¡ä»¶)
        
        #pragma unroll
        for (int i = 0; i < VSIZE; i++) 
            int idx = ccs[i]; // æ ·æœ¬ç‚¹å½’å±çš„æ–°ç°‡ ID
            atomicAdd(&CENTROIDS[idx].x, xy_values[i][0]); // å±€éƒ¨ç´¯åŠ  X åæ ‡
            atomicAdd(&CENTROIDS[idx].y, xy_values[i][1]); // å±€éƒ¨ç´¯åŠ  Y åæ ‡
            atomicAdd(&CENTROIDS[idx].z, 1);               // å±€éƒ¨ç´¯åŠ è®¡æ•° (ç°‡å†…ç‚¹çš„æ•°é‡)
        }
        // ... å†™å›æ–°çš„æ ‡ç­¾ labels[]
    }


  * **å±€éƒ¨ç´¯åŠ **ï¼šçº¿ç¨‹ä½¿ç”¨ **åŸå­æ“ä½œ (`atomicAdd`)** å°†è¿™ 4 ä¸ªæ ·æœ¬ç‚¹çš„åæ ‡å’Œè®¡æ•°ç´¯åŠ åˆ° Block çš„**å…±äº«å†…å­˜** `CENTROIDS` ä¸­ã€‚
      * åŸå­æ“ä½œæ˜¯å¿…è¦çš„ï¼Œå› ä¸º Block å†…çš„**å¤šä¸ªçº¿ç¨‹**å¯èƒ½åŒæ—¶å°†å®ƒä»¬çš„æ ·æœ¬ç‚¹åˆ†é…ç»™äº†**åŒä¸€ä¸ªç°‡ idx**ï¼Œå¿…é¡»ä¿è¯ç´¯åŠ æ“ä½œä¸ä¼šç›¸äº’è¦†ç›–ã€‚
  * **å†™å›æ ‡ç­¾**ï¼šçº¿ç¨‹å°† 4 ä¸ªæ ·æœ¬ç‚¹çš„æ–°çš„ç°‡ ID (`ccs`) å†™å›å…¨å±€å†…å­˜çš„ `labels` æ•°ç»„ã€‚

### 4\. æ”¶æ•›æ£€æŸ¥å’Œå…¨å±€è´¡çŒ®

#### æ£€æŸ¥å˜åŒ–

c
    for (int c = 0; c < VSIZE; c++) 
        if (local_labels[c] != ccs[c]) 
            CHANGES = 1; // å‘ç°å˜åŒ–ï¼
            break;
        }
    }
    // ...
    if (tx == 0 && (CHANGES || iteration == 0)) 
        *changes = 1; // çº¿ç¨‹ 0 å°†å˜åŒ–æ ‡å¿—å†™å…¥å…¨å±€å†…å­˜
    }


  * çº¿ç¨‹æ¯”è¾ƒæ—§æ ‡ç­¾ (`local_labels`) å’Œæ–°æ ‡ç­¾ (`ccs`)ã€‚åªè¦æœ‰ä¸€ä¸ªæ ·æœ¬ç‚¹å˜äº†ï¼Œå°±è®¾ç½®å…±äº«å†…å­˜å˜é‡ `CHANGES = 1`ã€‚
  * çº¿ç¨‹ 0 **ä»£è¡¨æ•´ä¸ª Block**ï¼Œå¦‚æœ `CHANGES=1`ï¼Œåˆ™å†™å…¥å…¨å±€å†…å­˜ `*changes = 1`ï¼Œå‘Šè¯‰ CPU **â€œç®—æ³•å°šæœªæ”¶æ•›ï¼Œéœ€è¦ç»§ç»­è¿­ä»£ï¼â€**

#### å…¨å±€ç´¯åŠ 

c
    #pragma unroll
    for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++) 
        // ...
        atomicAdd(&centroidCnts[offset], (int)(rel4.z)); // å…¨å±€ç´¯åŠ è®¡æ•°
        atomicAdd(&centroidSums[sum_off], rel4.x);       // å…¨å±€ç´¯åŠ  X æ€»å’Œ
        // ...
    }


  * æœ€åä¸€æ­¥ï¼Œçº¿ç¨‹å°† `CENTROIDS` ä¸­å­˜å‚¨çš„**å±€éƒ¨ç´¯åŠ ç»“æœ**ï¼ˆæœ¬ Block çš„è´¡çŒ®ï¼‰ï¼Œå†æ¬¡ä½¿ç”¨åŸå­æ“ä½œç´¯åŠ åˆ°**å…¨å±€å†…å­˜**ä¸­çš„ `centroidCnts` å’Œ `centroidSums` ä¸­ã€‚
  * è¿™äº›å…¨å±€ç´¯åŠ å™¨åŒ…å«äº†**æ‰€æœ‰ Block** å¯¹æ‰€æœ‰ç°‡çš„æ€»è´¡çŒ®ï¼Œä¾›ä¸‹ä¸€ä¸ªå†…æ ¸ `reset_centroids` è®¡ç®—æœ€ç»ˆçš„ä¸­å¿ƒç‚¹å¹³å‡ä½ç½®ã€‚


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question4:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­
why size is VSIZE?
    int local_labels[VSIZE] = 0};

answer:
è¿™æ˜¯ä¸€ä¸ªéå¸¸å¥½çš„ã€æ·±å…¥çš„é—®é¢˜ã€‚åœ¨é«˜æ€§èƒ½ CUDA ç¼–ç¨‹ä¸­ï¼Œåƒ `VSIZE` è¿™æ ·çš„å¸¸æ•°æ˜¯æ€§èƒ½ä¼˜åŒ–çš„å…³é”®ã€‚

**ç®€å•æ¥è¯´ï¼Œ`VSIZE` ä»£è¡¨äº†å‘é‡åŒ–ï¼ˆVectorizationï¼‰çš„æ­¥é•¿ï¼Œå³ä¸€ä¸ª CUDA çº¿ç¨‹ä¸€æ¬¡æ€§å¤„ç†å¤šå°‘ä¸ªæ•°æ®ç‚¹ã€‚**

### 1\. ä¸ºä»€ä¹ˆä½¿ç”¨ `VSIZE`ï¼Ÿï¼ˆå‘é‡åŒ–å’Œå†…å­˜åˆå¹¶ï¼‰

åœ¨ GPU ä¸Šï¼Œè®¿å­˜æ•ˆç‡è‡³å…³é‡è¦ã€‚GPU çº¿ç¨‹æ˜¯ä»¥ç»„ï¼ˆWarpï¼Œé€šå¸¸ 32 ä¸ªçº¿ç¨‹ï¼‰ä¸ºå•ä½æ‰§è¡Œçš„ã€‚å¦‚æœè¿™äº›çº¿ç¨‹åŒæ—¶è®¿é—®å†…å­˜ä¸­è¿ç»­çš„ã€ç›¸é‚»çš„åœ°å€ï¼Œé‚£ä¹ˆ GPU å¯ä»¥å°†è¿™ 32 æ¬¡ç‹¬ç«‹çš„è®¿å­˜è¯·æ±‚åˆå¹¶æˆä¸€ä¸ªæˆ–å°‘æ•°å‡ ä¸ªé«˜æ•ˆçš„å¤§è¯·æ±‚ã€‚è¿™è¢«ç§°ä¸º**å†…å­˜åˆå¹¶è®¿é—®ï¼ˆCoalesced Memory Accessï¼‰**ã€‚

#### A. æ¶ˆé™¤ `VSIZE` çš„ä½æ•ˆæ¨¡å‹ (Non-Vectorized)

å¦‚æœ `VSIZE=1`ï¼ˆæ¯ä¸ªçº¿ç¨‹åªå¤„ç†ä¸€ä¸ªç‚¹ï¼‰ï¼Œå½“çº¿ç¨‹ T_0 è¯»å– P_0 çš„ x, y åæ ‡ï¼Œçº¿ç¨‹ T_1 è¯»å– P_1 çš„ x, y åæ ‡æ—¶ï¼Œå®ƒä»¬ä¼šè®¿é—®å†…å­˜ä¸­çš„å››ä¸ªç‹¬ç«‹ä½ç½®ã€‚

#### B. å¼•å…¥ `VSIZE` çš„é«˜æ•ˆæ¨¡å‹ (Vectorized)

é€šå¸¸ï¼Œ`VSIZE` è®¾ç½®ä¸º **4**ã€‚è¿™æ˜¯å› ä¸ºå®ƒé…åˆ `float4` æˆ– `int4` ç­‰æ•°æ®ç±»å‹ï¼Œèƒ½å¤Ÿå®ç°æ›´æ·±å±‚æ¬¡çš„ä¼˜åŒ–ï¼š

1.  **æ•°æ®ç±»å‹ä¼˜åŒ–ï¼š** å½“ä½¿ç”¨ `float4` (åŒ…å« 4 ä¸ª float) å˜é‡æ—¶ï¼Œä¸€ä¸ªçº¿ç¨‹æ‰§è¡Œä¸€æ¬¡å†…å­˜è¯»å–æ“ä½œï¼Œå°±èƒ½å–å› 4 ä¸ªæµ®ç‚¹æ•°ã€‚è¿™æ¯”æ‰§è¡Œ 4 æ¬¡å•ç‹¬çš„ `float` è¯»å–æ•ˆç‡é«˜å¾—å¤šã€‚
2.  **çº¿ç¨‹çº§å‘é‡åŒ–ï¼š** æ¯ä¸ªçº¿ç¨‹ T_x ä¸å†å¤„ç†ä¸€ä¸ªç‚¹ï¼Œè€Œæ˜¯åŒæ—¶å¤„ç† P_4x}, P_4x+1}, P_4x+2}, P_4x+3 å››ä¸ªç‚¹ã€‚

**ç»“è®ºï¼š** ä½¿ç”¨ `VSIZE` å…è®¸ Kernel ä»£ç åˆ©ç”¨ç¡¬ä»¶çš„å‘é‡åŠ è½½èƒ½åŠ›ï¼Œæé«˜å†…å­˜å¸¦å®½åˆ©ç”¨ç‡ï¼Œå¹¶è®© GPU ä¿æŒâ€œå–‚é¥±â€çŠ¶æ€ã€‚

-----

### 2\. æ•°ç»„ `local_labels[VSIZE]` çš„ä½œç”¨

æ•°ç»„ `local_labels[VSIZE]` å°±æ˜¯ç”¨æ¥å­˜å‚¨å½“å‰çº¿ç¨‹ä¸€æ¬¡æ€§è¯»å–çš„è¿™ VSIZE ä¸ªæ•°æ®ç‚¹çš„**æ—§æ ‡ç­¾**ã€‚

#### A. ä»£ç ç‰‡æ®µï¼šåŠ è½½æ—§æ ‡ç­¾

c++
int local_labels[VSIZE] = 0}; // VSIZE=4, å­˜å‚¨ 4 ä¸ªæ—§æ ‡ç­¾

int within = loc < sample_size; // è¾¹ç•Œæ£€æŸ¥

if (within) 
    // ä½¿ç”¨ int4 æŒ‡é’ˆä¸€æ¬¡æ€§ä»å…¨å±€å†…å­˜ä¸­åŠ è½½ 4 ä¸ªæ ‡ç­¾
    const int4 *ptr = reinterpret_cast<const int4*>(&labels[loc]);
    int4 value = ptr[0];
    
    // å°† int4 çš„ 4 ä¸ªåˆ†é‡åˆ†æ•£åˆ° local_labels æ•°ç»„ä¸­
    local_labels[0] = value.x; 
    local_labels[1] = value.y;
    local_labels[2] = value.z; 
    local_labels[3] = value.w;
}


#### B. è¿½è¸ªç¤ºä¾‹ï¼ˆå‡è®¾ VSIZE=4ï¼‰

å‡è®¾æ•°æ®ç‚¹æ•°ç»„ `labels` çš„èµ·å§‹ä½ç½®å¦‚ä¸‹ï¼š

| ç´¢å¼• | 0 | 1 | 2 | 3 | 4 | 5 | ... |
| :--- | :--- | :--- | :--- | :--- | :--- | :--- | :--- |
| `labels` | 1 | 1 | 2 | 0 | 2 | 1 | ... |

çº¿ç¨‹ T_0ï¼ˆèµ·å§‹ç´¢å¼• `loc`=0ï¼‰æ‰§è¡ŒåŠ è½½æ“ä½œï¼š

1.  `ptr` æŒ‡å‘ `labels[0]`ã€‚
2.  `int4 value = ptr[0];` ä¸€æ¬¡æ€§è¯»å– `labels[0], labels[1], labels[2], labels[3]`ï¼Œå³ 1, 1, 2, 0ã€‚
3.  `local_labels` æ•°ç»„æœ€ç»ˆå­˜å‚¨ï¼š`[1, 1, 2, 0]`ã€‚

çº¿ç¨‹ T_0 ç°åœ¨æ‹¥æœ‰äº†å®ƒè´Ÿè´£å¤„ç†çš„ 4 ä¸ªæ•°æ®ç‚¹çš„æ—§æ ‡ç­¾ï¼Œç”¨äºåç»­çš„ä¸¤ä¸ªç›®çš„ï¼š

1.  **å˜æ›´æ£€æµ‹ï¼š** åœ¨ Kernel çš„æœ«å°¾ï¼Œå®ƒå°†è¿™äº› `local_labels` (æ—§æ ‡ç­¾) ä¸æ–°è®¡ç®—å‡ºçš„ `ccs` (æ–°æ ‡ç­¾) è¿›è¡Œæ¯”è¾ƒï¼Œä»¥åˆ¤æ–­ K-Means ç°‡åˆ†é…æ˜¯å¦å‘ç”Ÿå˜åŒ–ã€‚
2.  **å®‰å…¨å›å†™ï¼š** åœ¨è¿›è¡Œæ–°çš„ç°‡åˆ†é…å‰ï¼Œæ—§æ ‡ç­¾æ˜¯å†…å­˜ä¸­çš„åŸå§‹å€¼ï¼Œéœ€è¦å…ˆè¯»å–ã€‚

### æ€»ç»“

`local_labels[VSIZE]` æ•°ç»„æ˜¯å®ç°**çº¿ç¨‹çº§å‘é‡åŒ–**çš„å…³é”®å±€éƒ¨å­˜å‚¨ç©ºé—´ã€‚å®ƒå…è®¸ä¸€ä¸ªçº¿ç¨‹é«˜æ•ˆåœ°ä»å…¨å±€å†…å­˜ä¸­åŠ è½½ VSIZE ä¸ªæ—§æ ‡ç­¾ï¼Œå¹¶å°†å…¶ç”¨äºåç»­çš„è·ç¦»è®¡ç®—ã€ç°‡åˆ†é…å’Œå˜æ›´æ£€æµ‹é€»è¾‘ä¸­ã€‚è¿™æ˜¯ä¸€ç§å…¸å‹çš„ GPU ä¼˜åŒ–æ‰‹æ®µã€‚

//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question5:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    if (tx == 0 && (CHANGES || iteration == 0)) 
        *changes = 1;
    }

æ‚¨é—®çš„è¿™æ®µä»£ç ä½äº CUDA K-Means æ ¸å‡½æ•°ï¼ˆCluster Assignment Kernelï¼‰çš„æœ«å°¾ï¼Œæ˜¯æ•´ä¸ª K-Means ç®—æ³•**ç»ˆæ­¢æ¡ä»¶**åˆ¤æ–­çš„æ ¸å¿ƒéƒ¨åˆ†ã€‚

å®ƒçš„ç›®çš„æ˜¯ï¼š**å°†å½“å‰çº¿ç¨‹å—ï¼ˆBlockï¼‰çš„å±€éƒ¨çŠ¶æ€ï¼ŒåŒæ­¥åˆ°å…¨å±€çš„ç»ˆæ­¢æ ‡å¿—ä¸Šã€‚**

### 1. ä»£ç é€è¡Œè§£é‡Š

| ä»£ç  | è§£é‡Š | ä½œç”¨ |
| :--- | :--- | :--- |
| `if (tx == 0 && (...))` | åªæœ‰çº¿ç¨‹å—å†…çš„ç¬¬ä¸€ä¸ªçº¿ç¨‹ (`threadIdx.x == 0`) æ‰èƒ½æ‰§è¡Œæ‹¬å·å†…çš„é€»è¾‘ã€‚ | **åŸå­æ“ä½œé™åˆ¶ï¼š** ç¡®ä¿åªæœ‰ä¸€ä¸ªçº¿ç¨‹ï¼ˆ`tx=0`ï¼‰æ‰§è¡Œå…¨å±€å†…å­˜å†™å…¥æ“ä½œï¼Œé¿å…æ•°æ®ç«äº‰ã€‚ |
| `CHANGES` | è¿™æ˜¯ä¸€ä¸ªåœ¨çº¿ç¨‹å—å†…å£°æ˜çš„ `__shared__` å˜é‡ã€‚å¦‚æœåœ¨è¯¥ Block å¤„ç†çš„æ•°æ®ç‚¹ä¸­ï¼Œæœ‰ä»»ä½•ä¸€ä¸ªç‚¹çš„ç°‡åˆ†é…å‘ç”Ÿå˜åŒ–ï¼Œå®ƒå°±ä¼šè¢«è®¾ç½®ä¸º 1ã€‚ | **å±€éƒ¨å˜æ›´æ ‡å¿—ï¼š** ä»£è¡¨å½“å‰ Block çš„è®¡ç®—ç»“æœæ˜¯å¦å¯¼è‡´äº†ä»»ä½•æ ‡ç­¾æ›´æ–°ã€‚ |
| `iteration == 0` | è¿™æ˜¯ä¸€ä¸ªç‰¹æ®Šçš„è¾¹ç¼˜æ¡ä»¶ã€‚åœ¨ K-Means çš„**ç¬¬ä¸€æ¬¡è¿­ä»£**ä¸­ï¼Œå³ä½¿æ²¡æœ‰å‘ç”Ÿå˜åŒ–ï¼Œæˆ‘ä»¬ä¹Ÿåº”è¯¥ç»§ç»­ã€‚ | **é¦–æ¬¡è¿­ä»£ï¼š** ç¬¬ä¸€æ¬¡è¿­ä»£é€šå¸¸æ˜¯å¼ºåˆ¶è¿è¡Œçš„ï¼Œç”¨äºåˆå§‹åŒ–æ ‡ç­¾å’Œè´¨å¿ƒï¼Œå› æ­¤æ€»æ˜¯è®¾ç½® `changes = 1`ã€‚ |
| `*changes = 1;` | è¿™æ˜¯ä¸€ä¸ªå…¨å±€æŒ‡é’ˆï¼ŒæŒ‡å‘ä¸»æœºç«¯å†…å­˜ä¸­çš„ä¸€ä¸ªæ•´æ•°å˜é‡ï¼ˆé€šå¸¸åœ¨ä¸»æœºç«¯åˆå§‹åŒ–ä¸º 0ï¼‰ã€‚ | **å…¨å±€å˜æ›´æ ‡å¿—ï¼š** å¦‚æœå±€éƒ¨å‘ç°æœ‰å˜åŒ–ï¼Œæˆ–è€…è¿™æ˜¯ç¬¬ä¸€æ¬¡è¿è¡Œï¼Œå°±å°†å…¨å±€çš„ `changes` æ ‡å¿—è®¾ç½®ä¸º 1ã€‚ |

### 2. é€»è¾‘æµå’Œ K-Means ç»ˆæ­¢æ¡ä»¶

åœ¨ä¸»æœºç«¯ï¼ŒK-Means ç®—æ³•é€šå¸¸åœ¨ä¸€ä¸ª `do-while` å¾ªç¯ä¸­è¿è¡Œï¼Œå…¶ç»ˆæ­¢æ¡ä»¶æ˜¯ï¼š**æ‰€æœ‰æ•°æ®ç‚¹çš„ç°‡åˆ†é…åœ¨ä¸¤æ¬¡è¿­ä»£ä¹‹é—´éƒ½æ²¡æœ‰å‘ç”Ÿå˜åŒ–ã€‚**

| çŠ¶æ€ | å¾ªç¯åˆ¤æ–­ | `changes` çš„å€¼ |
| :--- | :--- | :--- |
| **å‘ç”Ÿå˜åŒ–** | `changes == 1` | ç»§ç»­ä¸‹ä¸€æ¬¡è¿­ä»£ |
| **æœªå‘ç”Ÿå˜åŒ–** | `changes == 0` | ç»ˆæ­¢ K-Means å¾ªç¯ |

**è¯¥ Kernel ä»£ç å¦‚ä½•è´¡çŒ®è¿™ä¸ªæ ‡å¿—ï¼š**

1.  åœ¨ Kernel è¿è¡Œä¹‹å‰ï¼Œä¸»æœºç«¯å°†å…¨å±€çš„ `*changes` åˆå§‹åŒ–ä¸º 0ã€‚
2.  Kernel å¯åŠ¨åï¼Œæ¯ä¸ªçº¿ç¨‹å—å¹¶è¡Œæ‰§è¡Œç°‡åˆ†é…å’Œå˜æ›´æ£€æµ‹ã€‚
3.  å¦‚æœçº¿ç¨‹å— B_i å‘ç°ä»»ä½•æ•°æ®ç‚¹çš„æ ‡ç­¾å˜åŒ–äº†ï¼Œå®ƒå°†å±€éƒ¨ `CHANGES` è®¾ç½®ä¸º 1ã€‚
4.  çº¿ç¨‹ T_i, 0ï¼ˆçº¿ç¨‹å— B_i çš„ç¬¬ä¸€ä¸ªçº¿ç¨‹ï¼‰æ‰§è¡Œæ‚¨é—®çš„è¿™æ®µä»£ç ã€‚ç”±äº `CHANGES` æ˜¯ 1ï¼Œå®ƒæ‰§è¡Œ `*changes = 1`ã€‚
5.  ç”±äºå¤šä¸ªçº¿ç¨‹å—å¯èƒ½åŒæ—¶å†™å…¥ `*changes`ï¼Œ**æœ€å¥½çš„å®ç°åº”è¯¥ä½¿ç”¨ `atomicOr`** è€Œä¸æ˜¯ç®€å•çš„èµ‹å€¼ï¼Œä»¥ç¡®ä¿æ¥è‡ªä»»ä½•çº¿ç¨‹å—çš„ `1` éƒ½èƒ½æ­£ç¡®åœ°è®¾ç½®å…¨å±€æ ‡å¿—ã€‚**ç„¶è€Œï¼Œåœ¨è¿™æ®µä»£ç ä¸­ï¼Œä½œè€…ä½¿ç”¨äº†ç®€å•çš„èµ‹å€¼ `*changes = 1`ï¼Œä¾èµ–äº CUDA çš„å†…å­˜æ¨¡å‹å’ŒåŸå­æ“ä½œçš„éšå¼é¡ºåºï¼Œä½†è¿™ä¸æ˜¯æœ€å®‰å…¨çš„åšæ³•ã€‚**ï¼ˆå‡è®¾ `*changes` å·²åœ¨å…¶ä»–åœ°æ–¹è¢«æ­£ç¡®è®¾ç½®ä¸º 0ï¼Œå¹¶ä¸”æ‰€æœ‰çº¿ç¨‹å—éƒ½åœ¨å†™å…¥ 1ï¼Œå®ƒæœ€ç»ˆä¼šæ˜¯ 1ï¼‰ã€‚

### 3. ç¤ºä¾‹è¿½è¸ª

å‡è®¾ K-Means æ­£åœ¨è¿›è¡Œç¬¬ 5 æ¬¡è¿­ä»£ (`iteration = 5`)ã€‚

#### åœºæ™¯ A: ç°‡åˆ†é…å‘ç”Ÿå˜åŒ– (ç»§ç»­è¿­ä»£)

| çº¿ç¨‹å— | å±€éƒ¨ `CHANGES` | `tx == 0` çº¿ç¨‹æ‰§è¡Œ | `*changes` å…¨å±€ç»“æœ |
| :--- | :--- | :--- | :--- |
| **Block 1** | 0 (æœªå˜åŒ–) | `if (0 || 5 == 0)` --> **False** | ä¸å˜ |
| **Block 2** | 1 (**å·²å˜åŒ–**) | `if (1 || 5 == 0)` --> **True** | `*changes = 1` |
| **Block 3** | 0 (æœªå˜åŒ–) | `if (0 || 5 == 0)` --> **False** | ä¸å˜ |

**æœ€ç»ˆç»“æœï¼š** ä¸»æœºç«¯è¯»å– `*changes` ä¸º 1ã€‚K-Means å¾ªç¯ç»§ç»­ã€‚

#### åœºæ™¯ B: ç°‡åˆ†é…æœªå‘ç”Ÿå˜åŒ– (ç»ˆæ­¢)

| çº¿ç¨‹å— | å±€éƒ¨ `CHANGES` | `tx == 0` çº¿ç¨‹æ‰§è¡Œ | `*changes` å…¨å±€ç»“æœ |
| :--- | :--- | :--- | :--- |
| **Block 1** | 0 (æœªå˜åŒ–) | False | ä¸å˜ |
| **Block 2** | 0 (æœªå˜åŒ–) | False | ä¸å˜ |

**æœ€ç»ˆç»“æœï¼š** ä¸»æœºç«¯è¯»å– `*changes` ä¸º 0ï¼ˆå› ä¸ºåˆå§‹å€¼ä¸º 0ï¼‰ã€‚K-Means å¾ªç¯ç»ˆæ­¢ã€‚

#### åœºæ™¯ C: ç¬¬ä¸€æ¬¡è¿­ä»£ (å¼ºåˆ¶è¿è¡Œ)

| çº¿ç¨‹å— | å±€éƒ¨ `CHANGES` | `tx == 0` çº¿ç¨‹æ‰§è¡Œ | `*changes` å…¨å±€ç»“æœ |
| :--- | :--- | :--- | :--- |
| **Block N** | ä»»æ„å€¼ | `if (CHANGES || 0 == 0)` --> **True** | `*changes = 1` |

**æœ€ç»ˆç»“æœï¼š** å³ä½¿ç¬¬ä¸€æ¬¡åˆ†é…æ²¡æœ‰å¯¼è‡´â€œå˜åŒ–â€ï¼ˆå› ä¸ºæ²¡æœ‰æ—§æ ‡ç­¾ï¼‰ï¼Œ`iteration == 0` ä¹Ÿä¼šå¼ºåˆ¶è®¾ç½® `*changes = 1`ï¼Œç¡®ä¿ K-Means è¿›å…¥ä¸‹ä¸€æ¬¡çœŸæ­£çš„è®¡ç®—ã€‚

//--------------------------------------------------------------------------------------------------




//--------------------------------------------------------------------------------------------------
/*
question6:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œæœ‰ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    #pragma unroll
    for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++) 
        int offset = tx + i * BLOCK_THREADS;
        if (offset >= k) break;
        float4 rel4 = CENTROIDS[offset];
        if ((int)(rel4.z)) 
            int sum_off = 2 * offset;
            atomicAdd(&centroidCnts[offset], (int)(rel4.z));
            atomicAdd(&centroidSums[sum_off], rel4.x);
            atomicAdd(&centroidSums[sum_off + 1], rel4.y);
        }
    }

answer:
æ‚¨é—®çš„è¿™æ®µä»£ç æ˜¯å¹¶è¡Œ K-Means ç®—æ³•ä¸­**å°†å±€éƒ¨èšåˆç»“æœå†™å…¥å…¨å±€å†…å­˜**çš„å…³é”®æ­¥éª¤ã€‚

å®ƒçš„ç›®çš„æ˜¯ï¼šåœ¨æ¯ä¸ªçº¿ç¨‹å—ï¼ˆBlockï¼‰å®Œæˆè‡ªå·±çš„å±€éƒ¨è®¡ç®—åï¼Œå°†å…±äº«å†…å­˜ä¸­çš„è´¨å¿ƒæ€»å’Œï¼ˆ`CENTROIDS`ï¼‰**å®‰å…¨åœ°ã€å¹¶å‘åœ°**ç´¯åŠ åˆ°å…¨å±€çš„è´¨å¿ƒæ€»å’Œæ•°ç»„ä¸­ã€‚

### 1. æ ¸å¿ƒé—®é¢˜ï¼šä»å±€éƒ¨åˆ°å…¨å±€

åœ¨ K-Means çš„ç°‡åˆ†é… Kernel ä¸­ï¼Œæ¯ä¸ªçº¿ç¨‹å— B_i éƒ½ä¼šè®¡ç®—ä¸€ä¸ªå±€éƒ¨çš„ç»“æœï¼š

* `__shared__ float4 CENTROIDS[MAX_TB]`ï¼šè¿™ä¸ªæ•°ç»„åªåœ¨çº¿ç¨‹å— B_i å†…éƒ¨æœ‰æ•ˆï¼Œå­˜å‚¨äº† B_i å†…éƒ¨æ•°æ®ç‚¹è´¡çŒ®çš„ (X å’Œ Y åæ ‡æ€»å’Œ, è®¡æ•°)ã€‚

ä¸ºäº†åœ¨ä¸‹ä¸€æ¬¡è¿­ä»£ä¸­è®¡ç®—æ–°çš„è´¨å¿ƒï¼Œæˆ‘ä»¬éœ€è¦æ‰€æœ‰çº¿ç¨‹å—çš„ç»“æœã€‚å› æ­¤ï¼Œè¿™æ®µä»£ç è´Ÿè´£å°† `CENTROIDS` æ•°ç»„ä¸­çš„å€¼ï¼Œç´¯åŠ åˆ°å…¨å±€æ•°ç»„ `centroidSums` å’Œ `centroidCnts` ä¸­ã€‚

### 2. ä»£ç é€è¡Œè§£é‡Š

å‡è®¾ `BLOCK_THREADS` ä¸ºçº¿ç¨‹å—å¤§å°ï¼Œ`MAX_TB` æ˜¯å…±äº«å†…å­˜ä¸­ä¸ºè´¨å¿ƒåˆ†é…çš„æœ€å¤§ç©ºé—´ã€‚

| ä»£ç  | è§£é‡Š | ä½œç”¨ |
| :--- | :--- | :--- |
| `#pragma unroll` | ç¼–è¯‘å™¨æŒ‡ä»¤ï¼Œè¦æ±‚å±•å¼€å¾ªç¯ã€‚ | æé«˜æ€§èƒ½ï¼Œå‡å°‘å¾ªç¯æ§åˆ¶å¼€é”€ã€‚ |
| `for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++)` | å¾ªç¯éå†æ•´ä¸ª `CENTROIDS` å…±äº«å†…å­˜æ•°ç»„ã€‚ | ç”±äº `CENTROIDS` å¯èƒ½æ¯”å•ä¸ªçº¿ç¨‹å—å¤§ï¼Œä½¿ç”¨æ­¥è¿› (`i * BLOCK_THREADS`) ç¡®ä¿æ‰€æœ‰çº¿ç¨‹å…±åŒéå†æ•´ä¸ªæ•°ç»„ã€‚ |
| `int offset = tx + i * BLOCK_THREADS;` | è®¡ç®—å½“å‰çº¿ç¨‹ `tx` åœ¨ `CENTROIDS` æ•°ç»„ä¸­è´Ÿè´£å¤„ç†çš„ç´¢å¼• `offset`ã€‚ | ç¡®ä¿ Block å†…çš„çº¿ç¨‹å‡åŒ€åˆ†æ‘Šè¯»å– `CENTROIDS` æ•°ç»„çš„å·¥ä½œã€‚ |
| `if (offset >= k) break;` | è¾¹ç•Œæ£€æŸ¥ã€‚`k` æ˜¯å®é™…çš„è´¨å¿ƒæ•°é‡ã€‚ | ç¡®ä¿åªå¤„ç†æœ‰æ•ˆçš„ã€æ­£åœ¨ä½¿ç”¨çš„è´¨å¿ƒç´¢å¼•ã€‚ |
| `float4 rel4 = CENTROIDS[offset];` | ä»å…±äº«å†…å­˜ä¸­è¯»å–å½“å‰è´¨å¿ƒç´¢å¼•çš„å±€éƒ¨èšåˆç»“æœã€‚ | `rel4.x` = å±€éƒ¨ X æ€»å’Œ; `rel4.y` = å±€éƒ¨ Y æ€»å’Œ; `rel4.z` = å±€éƒ¨è®¡æ•°ã€‚ |
| `if ((int)(rel4.z))` | æ£€æŸ¥è¯¥è´¨å¿ƒåœ¨å½“å‰ Block å†…æ˜¯å¦æœ‰ä»»ä½•æ•°æ®ç‚¹è¢«åˆ†é…ã€‚ | ä¼˜åŒ–ï¼šå¦‚æœè®¡æ•°ä¸º 0ï¼Œåˆ™è·³è¿‡åç»­æ˜‚è´µçš„åŸå­æ“ä½œã€‚ |
| `int sum_off = 2 * offset;` | è®¡ç®— `centroidSums` æ•°ç»„ä¸­çš„èµ·å§‹ç´¢å¼•ã€‚ | `centroidSums` æ˜¯ä¸€ä¸ªä¸€ç»´æ•°ç»„ï¼ŒæŒ‰ `[X0, Y0, X1, Y1, ...]` å­˜å‚¨ã€‚è¦è®¿é—® K_i çš„ X åæ ‡ï¼Œç´¢å¼•æ˜¯ 2iã€‚ |
| `atomicAdd(&centroidCnts[offset], (int)(rel4.z));` | **åŸå­åŠ æ³•ï¼š** å°†å±€éƒ¨è®¡æ•°ç´¯åŠ åˆ°å…¨å±€è®¡æ•°æ•°ç»„ã€‚ | **å…¨å±€åŒæ­¥ï¼š** ç¡®ä¿å¤šä¸ªçº¿ç¨‹å—å†™å…¥åŒä¸€ä¸ªå…¨å±€è´¨å¿ƒè®¡æ•°æ—¶ä¸ä¼šä¸¢å¤±æ•°æ®ã€‚ |
| `atomicAdd(&centroidSums[sum_off], rel4.x);` | **åŸå­åŠ æ³•ï¼š** å°†å±€éƒ¨ X æ€»å’Œç´¯åŠ åˆ°å…¨å±€ X æ€»å’Œã€‚ | **å…¨å±€åŒæ­¥ï¼š** ç´¯åŠ  X åæ ‡ã€‚ |
| `atomicAdd(&centroidSums[sum_off + 1], rel4.y);` | **åŸå­åŠ æ³•ï¼š** å°†å±€éƒ¨ Y æ€»å’Œç´¯åŠ åˆ°å…¨å±€ Y æ€»å’Œã€‚ | **å…¨å±€åŒæ­¥ï¼š** ç´¯åŠ  Y åæ ‡ã€‚ |

### 3. ç¤ºä¾‹è¿½è¸ªï¼šå…¨å±€åŸå­ç´¯åŠ 

å‡è®¾ï¼š
* æˆ‘ä»¬å…³æ³¨**ç°‡ ID 1** (`offset = 1`)ã€‚
* å…¨å±€å†…å­˜ä¸­ `centroidSums` å’Œ `centroidCnts` åˆå§‹å€¼ä¸º 0ã€‚
* K_1 åœ¨ `centroidSums` ä¸­çš„èµ·å§‹ç´¢å¼• `sum_off` æ˜¯ 2 * 1 = 2ã€‚

#### A. çº¿ç¨‹å— Block 1 çš„è´¡çŒ® (å±€éƒ¨ç»“æœ)

Block 1 ç»“æŸåï¼Œçº¿ç¨‹ T_i, j è´Ÿè´£å¤„ç† `CENTROIDS[1]`ï¼š
* `rel4.z` (è®¡æ•°) = 5
* `rel4.x` (X æ€»å’Œ) = 100.0
* `rel4.y` (Y æ€»å’Œ) = 200.0

| æ“ä½œ | ç›®æ ‡å…¨å±€æ•°ç»„ | åˆå§‹å€¼ | å†™å…¥å€¼ (æ¥è‡ª Block 1) |
| :--- | :--- | :--- | :--- |
| `atomicAdd` | `centroidCnts[1]` | 0 | + 5 |
| `atomicAdd` | `centroidSums[2]` (X) | 0 | + 100.0 |
| `atomicAdd` | `centroidSums[3]` (Y) | 0 | + 200.0 |

#### B. çº¿ç¨‹å— Block 2 çš„è´¡çŒ® (å¹¶å‘å†™å…¥)

Block 2 ç»“æŸåï¼Œå¦ä¸€ä¸ªçº¿ç¨‹ T_m, n è´Ÿè´£å¤„ç† `CENTROIDS[1]`ï¼š
* `rel4.z` (è®¡æ•°) = 3
* `rel4.x` (X æ€»å’Œ) = 50.0
* `rel4.y` (Y æ€»å’Œ) = 80.0

| æ“ä½œ | ç›®æ ‡å…¨å±€æ•°ç»„ | åˆå§‹å€¼ (æ¥è‡ª Block 1) | å†™å…¥å€¼ (æ¥è‡ª Block 2) |
| :--- | :--- | :--- | :--- |
| `atomicAdd` | `centroidCnts[1]` | 5 | + 3 |
| `atomicAdd` | `centroidSums[2]` (X) | 100.0 | + 50.0 |
| `atomicAdd` | `centroidSums[3]` (Y) | 200.0 | + 80.0 |

#### æœ€ç»ˆå…¨å±€ç»“æœï¼š

| æ•°ç»„ | ç´¢å¼• | æœ€ç»ˆå€¼ |
| :--- | :--- | :--- |
| `centroidCnts` | 1 | 5 + 3 = 8 |
| `centroidSums` | 2 (X) | 100.0 + 50.0 = 150.0 |
| `centroidSums` | 3 (Y) | 200.0 + 80.0 = 280.0 |

**ç»“è®ºï¼š** è¿™æ®µä»£ç é€šè¿‡ **å¹¶è¡Œå¾ªç¯** å’Œ **å…¨å±€åŸå­æ“ä½œ**ï¼Œç¡®ä¿äº†æ‰€æœ‰çº¿ç¨‹å—å¯¹åŒä¸€ä¸ªè´¨å¿ƒï¼ˆå¦‚ç°‡ ID 1ï¼‰çš„è´¡çŒ®éƒ½èƒ½è¢«æ­£ç¡®ã€å®‰å…¨åœ°ç´¯åŠ åˆ°å…¨å±€å†…å­˜ä¸­ï¼Œä»è€Œå®Œæˆå•æ¬¡ K-Means è¿­ä»£çš„å…¨å±€èšåˆä»»åŠ¡ã€‚




//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question7:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­

    for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++) 
        int offset = tx + i * BLOCK_THREADS;

æ‚¨é—®çš„è¿™ä¸¤è¡Œä»£ç æ˜¯ CUDA å¹¶è¡Œç¼–ç¨‹ä¸­ç”¨äº**çº¿ç¨‹å—å†…éƒ¨ååŒè®¿é—®ï¼ˆæˆ–å¤„ç†ï¼‰ä¸€ä¸ªå¤§å‹å…±äº«å†…å­˜æ•°ç»„**çš„ç»å…¸æ¨¡å¼ã€‚

è¿™ä¸ªæ¨¡å¼ç§°ä¸º **äº¤é”™å¼è®¿é—® (Strided Access)**ï¼Œç”¨äºç¡®ä¿ Block å†…æ‰€æœ‰çº¿ç¨‹éƒ½èƒ½å…¬å¹³ä¸”å®Œæ•´åœ°å¤„ç†ä¸€ä¸ªæ•°ç»„ï¼Œå³ä½¿è¿™ä¸ªæ•°ç»„æ¯”çº¿ç¨‹å—æœ¬èº«å¤§ã€‚

### 1. æ ¸å¿ƒé—®é¢˜ï¼šçº¿ç¨‹å—å¦‚ä½•å¤„ç†å¤§æ•°ç»„ï¼Ÿ

åœ¨æ‚¨çš„ K-Means ä»£ç ä¸­ï¼Œ`__shared__ float4 CENTROIDS[MAX_TB]` è¿™ä¸ªæ•°ç»„å­˜å‚¨äº†æ‰€æœ‰è´¨å¿ƒçš„å±€éƒ¨èšåˆç»“æœã€‚

* `MAX_TB`ï¼šè¿™ä¸ªæ•°ç»„çš„æ€»å¤§å°ï¼ˆå¯èƒ½å¾ˆå¤§ï¼Œæ¯”å¦‚ 1024ï¼‰ã€‚
* `BLOCK_THREADS`ï¼šå½“å‰çº¿ç¨‹å—çš„å®é™…çº¿ç¨‹æ•°ï¼ˆä¾‹å¦‚ 256ï¼‰ã€‚

**é—®é¢˜ï¼š** å¦‚æœ `MAX_TB = 1024`ï¼Œè€Œ `BLOCK_THREADS = 256`ï¼Œé‚£ä¹ˆ Block å†…çš„ 256 ä¸ªçº¿ç¨‹å¦‚ä½•è®¿é—® 1024 ä¸ªå…ƒç´ å‘¢ï¼Ÿ

**ç­”æ¡ˆï¼š** é€šè¿‡å¾ªç¯å’Œæ­¥é•¿è®¿é—®ï¼Œè®©æ¯ä¸ªçº¿ç¨‹å¤šæ¬¡è¯»å–æ•°æ®ã€‚

### 2. ä»£ç é€è¡Œè§£é‡Š

å‡è®¾ï¼š`MAX_TB = 1024`, `BLOCK_THREADS = 256`, çº¿ç¨‹ ID `tx` åœ¨ [0, 255] ä¹‹é—´ã€‚

| ä»£ç  | è§£é‡Š | ä½œç”¨ |
| :--- | :--- | :--- |
| `for (int i = 0; i < MAX_TB / BLOCK_THREADS; i++)` | å¾ªç¯æ¬¡æ•°ï¼š1024 / 256 = 4 æ¬¡ã€‚å¾ªç¯å˜é‡ i ä» 0 åˆ° 3ã€‚ | ç¡®ä¿å¾ªç¯è¦†ç›–æ•´ä¸ª `CENTROIDS` æ•°ç»„ã€‚ |
| `int offset = tx + i * BLOCK_THREADS;` | è®¡ç®—å½“å‰çº¿ç¨‹åœ¨æ¯ä¸€æ¬¡å¾ªç¯ä¸­éœ€è¦å¤„ç†çš„æ•°ç»„ç´¢å¼• `offset`ã€‚ | è¿™æ˜¯ **äº¤é”™å¼è®¿é—®** çš„æ ¸å¿ƒå…¬å¼ã€‚å®ƒè®©çº¿ç¨‹ tx åœ¨æ¯æ¬¡è¿­ä»£ä¸­è·³è·ƒä¸€ä¸ª Block çš„å¤§å°ã€‚ |

### 3. ç¤ºä¾‹è¿½è¸ªï¼šäº¤é”™å¼è®¿é—® (Strided Access)

æˆ‘ä»¬è¿½è¸ªä¸¤ä¸ªçº¿ç¨‹ T_0 å’Œ T_255ï¼Œçœ‹å®ƒä»¬æ˜¯å¦‚ä½•å…±åŒè¦†ç›– 1024 ä¸ªå…ƒç´ çš„ï¼š

| å¾ªç¯ i | çº¿ç¨‹ T_0 (`tx=0`) çš„ `offset` | çº¿ç¨‹ T_255 (`tx=255`) çš„ `offset` | è®¿é—®çš„æ•°ç»„ç´¢å¼•èŒƒå›´ |
| :--- | :--- | :--- | :--- |
| **0** | 0 + 0 * 256 = 0 | 255 + 0 * 256 = 255 | [0, 255] |
| **1** | 0 + 1 * 256 = 256 | 255 + 1 * 256 = 511 | [256, 511] |
| **2** | 0 + 2 * 256 = 512 | 255 + 2 * 256 = 767 | [512, 767] |
| **3** | 0 + 3 * 256 = 768 | 255 + 3 * 256 = 1023 | [768, 1023] |

**è§‚å¯Ÿç»“è®ºï¼š**

1.  **å®Œæ•´è¦†ç›–ï¼š** åœ¨ 4 æ¬¡å¾ªç¯ä¸­ï¼ŒBlock å†…çš„ 256 ä¸ªçº¿ç¨‹å…±åŒè®¿é—®äº†ä»ç´¢å¼• 0 åˆ° 1023 çš„æ‰€æœ‰ 1024 ä¸ªå…ƒç´ ã€‚
2.  **äº¤é”™è®¿é—®ï¼š** çº¿ç¨‹ T_0 åœ¨æ¯æ¬¡å¾ªç¯ä¸­è´Ÿè´£ 0, 256, 512, 768 å¤„çš„å…ƒç´ ï¼›çº¿ç¨‹ T_255 è´Ÿè´£ 255, 511, 767, 1023 å¤„çš„å…ƒç´ ã€‚æ¯ä¸ªçº¿ç¨‹è´Ÿè´£å¤„ç†çš„å…ƒç´ ï¼Œåœ¨å†…å­˜ä¸­ç›¸éš”äº† 256 ä¸ªä½ç½®ã€‚

### 4. ä¸ºä»€ä¹ˆè¿™ä¹ˆåšæ˜¯é«˜æ•ˆçš„ï¼Ÿ

è¿™ç§æ¨¡å¼ï¼ˆçº¿ç¨‹ ID + å¾ªç¯æ­¥é•¿ * Block å¤§å°ï¼‰åœ¨ CUDA ä¸­æ˜¯æ ‡å‡†çš„ï¼Œå› ä¸ºå®ƒä¿è¯äº†ï¼š

* **è´Ÿè½½å‡è¡¡ï¼š** æ¯ä¸ªçº¿ç¨‹ï¼ˆé™¤äº†è¾¹ç•Œæ£€æŸ¥å¯¼è‡´æå‰é€€å‡ºçš„ï¼‰éƒ½æ‰§è¡Œäº†ç›¸åŒæ¬¡æ•°çš„å¾ªç¯ï¼Œå·¥ä½œé‡ç›¸ç­‰ã€‚
* **å†…å­˜åˆå¹¶ï¼ˆCoalescingï¼‰ï¼š** è™½ç„¶æ¯ä¸ªçº¿ç¨‹è´Ÿè´£çš„å…ƒç´ æ˜¯äº¤é”™çš„ï¼Œä½†åœ¨åŒä¸€æ—¶é—´ç‚¹ï¼ˆåŒä¸€å¾ªç¯ iï¼‰ï¼Œæ‰€æœ‰çº¿ç¨‹ T_0 åˆ° T_255 éƒ½åœ¨è®¿é—®å†…å­˜ä¸­è¿ç»­çš„ 256 ä¸ªå…ƒç´ ï¼ˆä» i * 256 åˆ° i * 256 + 255ï¼‰ã€‚è¿™ä½¿å¾— GPU èƒ½å¤Ÿå°† 256 ä¸ªçº¿ç¨‹çš„è®¿é—®è¯·æ±‚åˆå¹¶æˆå°‘æ•°å‡ ä¸ªé«˜æ•ˆçš„å†…å­˜äº‹åŠ¡ï¼Œæœ€å¤§åŒ–å¸¦å®½ã€‚

å› æ­¤ï¼Œè¿™æ®µä»£ç æ˜¯ç”¨äºé«˜æ•ˆåœ°å°†å…±äº«å†…å­˜ä¸­çš„å±€éƒ¨èšåˆç»“æœ**å†™å…¥**å…¨å±€å†…å­˜çš„æ ‡å‡†ä¸”é«˜æ•ˆçš„å¹¶è¡Œæ¨¡å¼ã€‚


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question8:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­



//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question10:

ä¸ç†è§£ï¼Œè¯·è§£é‡Šï¼Œç”¨ä¾‹å­


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question11:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question12:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question13:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question14:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question15:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question16:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question17:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question18:


//--------------------------------------------------------------------------------------------------


//--------------------------------------------------------------------------------------------------
/*
question19:


//--------------------------------------------------------------------------------------------------



//--------------------------------------------------------------------------------------------------
/*
question20:


//--------------------------------------------------------------------------------------------------
